(window.__LOADABLE_LOADED_CHUNKS__=window.__LOADABLE_LOADED_CHUNKS__||[]).push([[5],{QJEp:function(t,e,n){"use strict";n.r(e),e.default='/** @noSelfInFile */\n/// <reference types="lua-types/5.1" />\n/// <reference types="typescript-to-lua/language-extensions" />\n\n// DEFOLD. stable version 1.2.186 (1f748d5b0a84e8b5c58bf747e4c48d153ef77a52)\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare type hash = {\n}\n\ndeclare type url = {\n}\n\ndeclare type node = {\n}\n\ndeclare type buffer = {\n}\n\ndeclare type bufferstream = Array<number> & LuaUserdata & {\n}\n\ndeclare namespace vmath {\n\n\texport type vector3 = number & {\n\t\tx: number,\n\t\ty: number,\n\t\tz: number,\n\t}\n\n\texport type vector4 = number & {\n\t\tx: number,\n\t\ty: number,\n\t\tz: number,\n\t\tw: number,\n\t}\n\n\texport type matrix4 = number & {\n\t\tc0: vmath.vector4,\n\t\tc1: vmath.vector4,\n\t\tc2: vmath.vector4,\n\t\tc3: vmath.vector4,\n\t\tm01: number,\n\t\tm02: number,\n\t\tm03: number,\n\t\tm04: number,\n\t\tm11: number,\n\t\tm12: number,\n\t\tm13: number,\n\t\tm14: number,\n\t\tm21: number,\n\t\tm22: number,\n\t\tm23: number,\n\t\tm24: number,\n\t\tm31: number,\n\t\tm32: number,\n\t\tm33: number,\n\t\tm34: number,\n\t}\n\n\texport type quaternion = number & {\n\t\tx: number,\n\t\ty: number,\n\t\tz: number,\n\t\tw: number,\n\t}\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\n\n/**\n* All ids in the engine are represented as hashes, so a string needs to be hashed\n* before it can be compared with an id.\n* @param s  string to hash\n* @return hash  a hashed string\n*/\ndeclare function hash(s: string): hash\n\n/**\n* Returns a hexadecimal representation of a hash value.\n* The returned string is always padded with leading zeros.\n* @param h  hash value to get hex string for\n* @return hex  hex representation of the hash\n*/\ndeclare function hash_to_hex(h: hash): string\n\n/**\n* Pretty printing of Lua values. This function prints Lua values\n* in a manner similar to +print()+, but will also recurse into tables\n* and pretty print them. There is a limit to how deep the function\n* will recurse.\n* @param v  value to print\n*/\ndeclare function pprint(v: any): void\n\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace crash {\n\n\t/**\n\t* android build fingerprint\n\t*/\n\texport let SYSFIELD_ANDROID_BUILD_FINGERPRINT: any\n\n\t/**\n\t* system device language as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_DEVICE_LANGUAGE: any\n\n\t/**\n\t* device model as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_DEVICE_MODEL: any\n\n\t/**\n\t* engine version as hash\n\t*/\n\texport let SYSFIELD_ENGINE_HASH: any\n\n\t/**\n\t* engine version as release number\n\t*/\n\texport let SYSFIELD_ENGINE_VERSION: any\n\n\t/**\n\t* system language as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_LANGUAGE: any\n\n\t/**\n\t* device manufacturer as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_MANUFACTURER: any\n\n\t/**\n\t* The max number of sysfields.\n\t*/\n\texport let SYSFIELD_MAX: any\n\n\t/**\n\t* system name as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_SYSTEM_NAME: any\n\n\t/**\n\t* system version as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_SYSTEM_VERSION: any\n\n\t/**\n\t* system territory as reported by sys.get_sys_info\n\t*/\n\texport let SYSFIELD_TERRITORY: any\n\n\t/**\n\t* The max number of user fields.\n\t*/\n\texport let USERFIELD_MAX: any\n\n\t/**\n\t* The max size of a single user field.\n\t*/\n\texport let USERFIELD_SIZE: any\n\n\t/**\n\t* A table is returned containing the addresses of the call stack.\n\t* @param handle  crash dump handle\n\t* @return backtrace  table containing the backtrace\n\t*/\n\texport function get_backtrace(handle: number): any\n\n\t/**\n\t* The format of read text blob is platform specific\n\t* and not guaranteed\n\t* but can be useful for manual inspection.\n\t* @param handle  crash dump handle\n\t* @return blob  string with the platform specific data\n\t*/\n\texport function get_extra_data(handle: number): string\n\n\t/**\n\t* The function returns a table containing entries with sub-tables that\n\t* have fields \'name\' and \'address\' set for all loaded modules.\n\t* @param handle  crash dump handle\n\t* @return modules  module table\n\t*/\n\texport function get_modules(handle: number): any\n\n\t/**\n\t* read signal number from a crash report\n\t* @param handle  crash dump handle\n\t* @return signal  signal number\n\t*/\n\texport function get_signum(handle: number): number\n\n\t/**\n\t* reads a system field from a loaded crash dump\n\t* @param handle  crash dump handle\n\t* @param index  \n\t* @return value  value recorded in the crash dump, or nil if it didn\'t exist\n\t*/\n\texport function get_sys_field(handle: number, index: any): string\n\n\t/**\n\t* reads user field from a loaded crash dump\n\t* @param handle  crash dump handle\n\t* @param index  user data slot index\n\t* @return value  user data value recorded in the crash dump\n\t*/\n\texport function get_user_field(handle: number, index: number): string\n\n\t/**\n\t* The crash dump will be removed from disk upon a successful\n\t* load, so loading is one-shot.\n\t* @return handle  handle to the loaded dump, or nil if no dump was found\n\t*/\n\texport function load_previous(): number\n\n\t/**\n\t* releases a previously loaded crash dump\n\t* @param handle  handle to loaded crash dump\n\t*/\n\texport function release(handle: number): void\n\n\t/**\n\t* Crashes occuring before the path is set will be stored to a default engine location.\n\t* @param path  file path to use\n\t*/\n\texport function set_file_path(path: string): void\n\n\t/**\n\t* Store a user value that will get written to a crash dump when\n\t* a crash occurs. This can be user id:s, breadcrumb data etc.\n\t* There are 32 slots indexed from 0. Each slot stores at most 255 characters.\n\t* @param index  slot index. 0-indexed\n\t* @param value  string value to store\n\t*/\n\texport function set_user_field(index: number, value: string): void\n\n\t/**\n\t* Performs the same steps as if a crash had just occured but\n\t* allows the program to continue.\n\t* The generated dump can be read by crash.load_previous\n\t*/\n\texport function write_dump(): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace go {\n\n\t/**\n\t* Post this message to a game object instance to make that instance acquire the user input focus.\n\t* User input is distributed by the engine to every instance that has\n\t* requested it. The last instance to request focus will receive it first.\n\t* This means that the scripts in the instance will have first-hand-chance\n\t* at reacting on user input, possibly consuming it (by returning\n\t* `true` from `on_input`) so that no other instances\n\t* can react on it. The most common case is for a script to send this message\n\t* to itself when it needs to respond to user input.\n\t* A script belonging to an instance which has the user input focus will\n\t* receive the input actions in its `on_input` callback function.\n\t* See on_input for more information on how user input can be\n\t* handled.\n\t*/\n\texport type acquire_input_focus = "acquire_input_focus"\n\n\t/**\n\t* This message disables the receiving component. All components are enabled by default, which means they will receive input, updates\n\t* and be a part of the simulation. A component is disabled when it receives the `disable` message.\n\t* undefined Components that currently supports this message are:\n\t* \n\t* - Collection Proxy\n\t* - Collision Object\n\t* - Gui\n\t* - Label\n\t* - Spine Model\n\t* - Sprite\n\t* - Tile Grid\n\t* - Model\n\t* \n\t*/\n\texport type disable = "disable"\n\n\t/**\n\t* This message enables the receiving component. All components are enabled by default, which means they will receive input, updates\n\t* and be a part of the simulation. A component is disabled when it receives the `disable` message.\n\t* undefined Components that currently supports this message are:\n\t* \n\t* - Collection Proxy\n\t* - Collision Object\n\t* - Gui\n\t* - Label\n\t* - Spine Model\n\t* - Sprite\n\t* - Tile Grid\n\t* - Model\n\t* \n\t*/\n\texport type enable = "enable"\n\n\t/**\n\t* The rotation of the game object expressed in Euler angles.\n\t* Euler angles are specified in degrees in the interval (-360, 360).\n\t* The type of the property is vector3.\n\t*/\n\texport let euler: any\n\n\n\t/**\n\t* in-back\n\t*/\n\texport let EASING_INBACK: any\n\n\t/**\n\t* in-bounce\n\t*/\n\texport let EASING_INBOUNCE: any\n\n\t/**\n\t* in-circlic\n\t*/\n\texport let EASING_INCIRC: any\n\n\t/**\n\t* in-cubic\n\t*/\n\texport let EASING_INCUBIC: any\n\n\t/**\n\t* in-elastic\n\t*/\n\texport let EASING_INELASTIC: any\n\n\t/**\n\t* in-exponential\n\t*/\n\texport let EASING_INEXPO: any\n\n\t/**\n\t* in-out-back\n\t*/\n\texport let EASING_INOUTBACK: any\n\n\t/**\n\t* in-out-bounce\n\t*/\n\texport let EASING_INOUTBOUNCE: any\n\n\t/**\n\t* in-out-circlic\n\t*/\n\texport let EASING_INOUTCIRC: any\n\n\t/**\n\t* in-out-cubic\n\t*/\n\texport let EASING_INOUTCUBIC: any\n\n\t/**\n\t* in-out-elastic\n\t*/\n\texport let EASING_INOUTELASTIC: any\n\n\t/**\n\t* in-out-exponential\n\t*/\n\texport let EASING_INOUTEXPO: any\n\n\t/**\n\t* in-out-quadratic\n\t*/\n\texport let EASING_INOUTQUAD: any\n\n\t/**\n\t* in-out-quartic\n\t*/\n\texport let EASING_INOUTQUART: any\n\n\t/**\n\t* in-out-quintic\n\t*/\n\texport let EASING_INOUTQUINT: any\n\n\t/**\n\t* in-out-sine\n\t*/\n\texport let EASING_INOUTSINE: any\n\n\t/**\n\t* in-quadratic\n\t*/\n\texport let EASING_INQUAD: any\n\n\t/**\n\t* in-quartic\n\t*/\n\texport let EASING_INQUART: any\n\n\t/**\n\t* in-quintic\n\t*/\n\texport let EASING_INQUINT: any\n\n\t/**\n\t* in-sine\n\t*/\n\texport let EASING_INSINE: any\n\n\t/**\n\t* linear interpolation\n\t*/\n\texport let EASING_LINEAR: any\n\n\t/**\n\t* out-back\n\t*/\n\texport let EASING_OUTBACK: any\n\n\t/**\n\t* out-bounce\n\t*/\n\texport let EASING_OUTBOUNCE: any\n\n\t/**\n\t* out-circlic\n\t*/\n\texport let EASING_OUTCIRC: any\n\n\t/**\n\t* out-cubic\n\t*/\n\texport let EASING_OUTCUBIC: any\n\n\t/**\n\t* out-elastic\n\t*/\n\texport let EASING_OUTELASTIC: any\n\n\t/**\n\t* out-exponential\n\t*/\n\texport let EASING_OUTEXPO: any\n\n\t/**\n\t* out-in-back\n\t*/\n\texport let EASING_OUTINBACK: any\n\n\t/**\n\t* out-in-bounce\n\t*/\n\texport let EASING_OUTINBOUNCE: any\n\n\t/**\n\t* out-in-circlic\n\t*/\n\texport let EASING_OUTINCIRC: any\n\n\t/**\n\t* out-in-cubic\n\t*/\n\texport let EASING_OUTINCUBIC: any\n\n\t/**\n\t* out-in-elastic\n\t*/\n\texport let EASING_OUTINELASTIC: any\n\n\t/**\n\t* out-in-exponential\n\t*/\n\texport let EASING_OUTINEXPO: any\n\n\t/**\n\t* out-in-quadratic\n\t*/\n\texport let EASING_OUTINQUAD: any\n\n\t/**\n\t* out-in-quartic\n\t*/\n\texport let EASING_OUTINQUART: any\n\n\t/**\n\t* out-in-quintic\n\t*/\n\texport let EASING_OUTINQUINT: any\n\n\t/**\n\t* out-in-sine\n\t*/\n\texport let EASING_OUTINSINE: any\n\n\t/**\n\t* out-quadratic\n\t*/\n\texport let EASING_OUTQUAD: any\n\n\t/**\n\t* out-quartic\n\t*/\n\texport let EASING_OUTQUART: any\n\n\t/**\n\t* out-quintic\n\t*/\n\texport let EASING_OUTQUINT: any\n\n\t/**\n\t* out-sine\n\t*/\n\texport let EASING_OUTSINE: any\n\n\t/**\n\t* loop backward\n\t*/\n\texport let PLAYBACK_LOOP_BACKWARD: any\n\n\t/**\n\t* loop forward\n\t*/\n\texport let PLAYBACK_LOOP_FORWARD: any\n\n\t/**\n\t* ping pong loop\n\t*/\n\texport let PLAYBACK_LOOP_PINGPONG: any\n\n\t/**\n\t* no playback\n\t*/\n\texport let PLAYBACK_NONE: any\n\n\t/**\n\t* once backward\n\t*/\n\texport let PLAYBACK_ONCE_BACKWARD: any\n\n\t/**\n\t* once forward\n\t*/\n\texport let PLAYBACK_ONCE_FORWARD: any\n\n\t/**\n\t* once ping pong\n\t*/\n\texport let PLAYBACK_ONCE_PINGPONG: any\n\n\t/**\n\t* This is only supported for numerical properties. If the node property is already being\n\t* animated, that animation will be canceled and replaced by the new one.\n\t* If a `complete_function` (lua function) is specified, that function will be called when the animation has completed.\n\t* By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.\n\t* ⚠ If you call `go.animate()` from a game object\'s `final()` function,\n\t* any passed `complete_function` will be ignored and never called upon animation completion.\n\t* See the properties guide for which properties can be animated and the animation guide for how to animate them.\n\t* @param url  url of the game object or component having the property\n\t* @param property  id of the property to animate\n\t* @param playback  playback mode of the animation\n\n- `go.PLAYBACK_ONCE_FORWARD`\n- `go.PLAYBACK_ONCE_BACKWARD`\n- `go.PLAYBACK_ONCE_PINGPONG`\n- `go.PLAYBACK_LOOP_FORWARD`\n- `go.PLAYBACK_LOOP_BACKWARD`\n- `go.PLAYBACK_LOOP_PINGPONG`\n\n\t* @param to  target property value\n\t* @param easing  easing to use during animation. Either specify a constant, see the animation guide for a complete list, or a vmath.vector with a curve\n\t* @param duration  duration of the animation in seconds\n\t* @param delay  delay before the animation starts in seconds\n\t* @param complete_function  optional function to call when the animation has completed\n\n`self`\n\nThe current object.\n\n`url`\n\nThe game object or component instance for which the property is animated.\n\n`property`\n\nThe id of the animated property.\n\n\n\t*/\n\texport function animate(url: string | hash | url, property: string | hash, playback: any, to: number | vmath.vector3 | vmath.vector4 | vmath.quaternion, easing: any, duration: number, delay?: number, complete_function?: any): void\n\n\t/**\n\t* By calling this function, all stored animations of the given property will be canceled.\n\t* See the properties guide for which properties can be animated and the animation guide for how to animate them.\n\t* @param url  url of the game object or component having the property\n\t* @param property  ide of the property to animate\n\t*/\n\texport function cancel_animations(url: string | hash | url, property: string | hash): void\n\n\t/**\n\t* Delete one or more game objects identified by id. Deletion is asynchronous meaning that\n\t* the game object(s) are scheduled for deletion which will happen at the end of the current\n\t* frame. Note that game objects scheduled for deletion will be counted against\n\t* `max_instances` in "game.project" until they are actually removed.\n\t* ⚠ Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using `particlefx.stop()`.\n\t* ⚠ Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using `sound.stop()`.\n\t* @param id  optional id or table of id\'s of the instance(s) to delete, the instance of the calling script is deleted by default\n\t* @param recursive  optional boolean, set to true to recursively delete child hiearchy in child to parent order\n\t*/\n\t function delete$(id?: any, recursive?: boolean): void\n\texport { delete$ as delete }\n\n\t/**\n\t* gets a named property of the specified game object or component\n\t* @param url  url of the game object or component having the property\n\t* @param property  id of the property to retrieve\n\t* @return value  the value of the specified property\n\t*/\n\texport function get(url: string | hash | url, property: string | hash): any\n\n\t/**\n\t* Returns or constructs an instance identifier. The instance id is a hash\n\t* of the absolute path to the instance.\n\t* \n\t* - If `path` is specified, it can either be absolute or relative to the instance of the calling script.\n\t* - If `path` is not specified, the id of the game object instance the script is attached to will be returned.\n\t* \n\t* @param path  path of the instance for which to return the id\n\t* @return id  instance id\n\t*/\n\texport function get_id(path?: string): hash\n\n\t/**\n\t* Get the parent for a game object instance.\n\t* @param id  optional id of the game object instance to get parent for, defaults to the instance containing the calling script\n\t* @return parent_id  parent instance or nil\n\t*/\n\texport function get_parent(id?: string | hash | url): hash\n\n\t/**\n\t* The position is relative the parent (if any). Use go.get_world_position to retrieve the global world position.\n\t* @param id  optional id of the game object instance to get the position for, by default the instance of the calling script\n\t* @return position  instance position\n\t*/\n\texport function get_position(id?: string | hash | url): vmath.vector3\n\n\t/**\n\t* The rotation is relative to the parent (if any). Use go.get_world_rotation to retrieve the global world rotation.\n\t* @param id  optional id of the game object instance to get the rotation for, by default the instance of the calling script\n\t* @return rotation  instance rotation\n\t*/\n\texport function get_rotation(id?: string | hash | url): vmath.quaternion\n\n\t/**\n\t* The scale is relative the parent (if any). Use go.get_world_scale to retrieve the global world 3D scale factor.\n\t* @param id  optional id of the game object instance to get the scale for, by default the instance of the calling script\n\t* @return scale  instance scale factor\n\t*/\n\texport function get_scale(id?: string | hash | url): vmath.vector3\n\n\t/**\n\t* The uniform scale is relative the parent (if any). If the underlying scale vector is non-uniform the min element of the vector is returned as the uniform scale factor.\n\t* @param id  optional id of the game object instance to get the uniform scale for, by default the instance of the calling script\n\t* @return scale  uniform instance scale factor\n\t*/\n\texport function get_scale_uniform(id?: string | hash | url): number\n\n\t/**\n\t* The function will return the world position calculated at the end of the previous frame.\n\t* Use go.get_position to retrieve the position relative to the parent.\n\t* @param id  optional id of the game object instance to get the world position for, by default the instance of the calling script\n\t* @return position  instance world position\n\t*/\n\texport function get_world_position(id?: string | hash | url): vmath.vector3\n\n\t/**\n\t* The function will return the world rotation calculated at the end of the previous frame.\n\t* Use go.get_rotation to retrieve the rotation relative to the parent.\n\t* @param id  optional id of the game object instance to get the world rotation for, by default the instance of the calling script\n\t* @return rotation  instance world rotation\n\t*/\n\texport function get_world_rotation(id?: string | hash | url): vmath.quaternion\n\n\t/**\n\t* The function will return the world 3D scale factor calculated at the end of the previous frame.\n\t* Use go.get_scale to retrieve the 3D scale factor relative to the parent.\n\t* This vector is derived by decomposing the transformation matrix and should be used with care.\n\t* For most cases it should be fine to use go.get_world_scale_uniform instead.\n\t* @param id  optional id of the game object instance to get the world scale for, by default the instance of the calling script\n\t* @return scale  instance world 3D scale factor\n\t*/\n\texport function get_world_scale(id?: string | hash | url): vmath.vector3\n\n\t/**\n\t* The function will return the world scale factor calculated at the end of the previous frame.\n\t* Use go.get_scale_uniform to retrieve the scale factor relative to the parent.\n\t* @param id  optional id of the game object instance to get the world scale for, by default the instance of the calling script\n\t* @return scale  instance world scale factor\n\t*/\n\texport function get_world_scale_uniform(id?: string | hash | url): number\n\n\t/**\n\t* The function will return the world transform matrix calculated at the end of the previous frame.\n\t* @param id  optional id of the game object instance to get the world transform for, by default the instance of the calling script\n\t* @return transform  instance world transform\n\t*/\n\texport function get_world_transform(id?: string | hash | url): vmath.matrix4\n\n\t/**\n\t* This function defines a property which can then be used in the script through the self-reference.\n\t* The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.\n\t* Note that you can only use this function outside any callback-functions like init and update.\n\t* @param name  the id of the property\n\t* @param value  default value of the property. In the case of a url, only the empty constructor msg.url() is allowed. In the case of a resource one of the resource constructors (eg resource.atlas(), resource.font() etc) is expected.\n\t*/\n\texport function property(name: string, value: any): void\n\n\t/**\n\t* sets a named property of the specified game object or component, or a material constant\n\t* @param url  url of the game object or component having the property\n\t* @param property  id of the property to set\n\t* @param value  the value to set\n\t*/\n\texport function set(url: string | hash | url, property: string | hash, value: any): void\n\n\t/**\n\t* Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,\n\t* like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world\n\t* space.\n\t* This function will generate a `set_parent` message. It is not until the message has been processed that the change actually takes effect. This\n\t* typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the\n\t* engine.\n\t* @param id  optional id of the game object instance to set parent for, defaults to the instance containing the calling script\n\t* @param parent_id  optional id of the new parent game object, defaults to detaching game object from its parent\n\t* @param keep_world_transform  optional boolean, set to true to maintain the world transform when changing spaces. Defaults to false.\n\t*/\n\texport function set_parent(id?: string | hash | url, parent_id?: string | hash | url, keep_world_transform?: boolean): void\n\n\t/**\n\t* The position is relative to the parent (if any). The global world position cannot be manually set.\n\t* @param position  position to set\n\t* @param id  optional id of the game object instance to set the position for, by default the instance of the calling script\n\t*/\n\texport function set_position(position: vmath.vector3, id?: string | hash | url): void\n\n\t/**\n\t* The rotation is relative to the parent (if any). The global world rotation cannot be manually set.\n\t* @param rotation  rotation to set\n\t* @param id  optional id of the game object instance to get the rotation for, by default the instance of the calling script\n\t*/\n\texport function set_rotation(rotation: vmath.quaternion, id?: string | hash | url): void\n\n\t/**\n\t* The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.\n\t* ⚠ Physics are currently not affected when setting scale from this function.\n\t* @param scale  vector or uniform scale factor, must be greater than 0\n\t* @param id  optional id of the game object instance to get the scale for, by default the instance of the calling script\n\t*/\n\texport function set_scale(scale: number | vmath.vector3, id?: string | hash | url): void\n\n\n\n\n\n\t/**\n\t* The position of the game object.\n\t* The type of the property is vector3.\n\t*/\n\texport let position: any\n\n\t/**\n\t* Post this message to an instance to make that instance release the user input focus.\n\t* See acquire_input_focus for more information on how the user input handling\n\t* works.\n\t*/\n\texport type release_input_focus = "release_input_focus"\n\n\t/**\n\t* The rotation of the game object.\n\t* The type of the property is quaternion.\n\t*/\n\texport let rotation: any\n\n\t/**\n\t* The uniform scale of the game object. The type of the property is number.\n\t*/\n\texport let scale: any\n\n\t/**\n\t* When this message is sent to an instance, it sets the parent of that instance. This means that the instance will exist\n\t* in the geometrical space of its parent, like a basic transformation hierarchy or scene graph. If no parent is specified,\n\t* the instance will be detached from any parent and exist in world space. A script can send this message to itself to set\n\t* the parent of its instance.\n\t*/\n\texport type set_parent = "set_parent"\n\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace gui {\n\n\n\t/**\n\t* fit adjust mode\n\t*/\n\texport let ADJUST_FIT: any\n\n\t/**\n\t* stretch adjust mode\n\t*/\n\texport let ADJUST_STRETCH: any\n\n\t/**\n\t* zoom adjust mode\n\t*/\n\texport let ADJUST_ZOOM: any\n\n\t/**\n\t* bottom y-anchor\n\t*/\n\texport let ANCHOR_BOTTOM: any\n\n\t/**\n\t* left x-anchor\n\t*/\n\texport let ANCHOR_LEFT: any\n\n\t/**\n\t* no anchor\n\t*/\n\texport let ANCHOR_NONE: any\n\n\t/**\n\t* right x-anchor\n\t*/\n\texport let ANCHOR_RIGHT: any\n\n\t/**\n\t* top y-anchor\n\t*/\n\texport let ANCHOR_TOP: any\n\n\t/**\n\t* additive blending\n\t*/\n\texport let BLEND_ADD: any\n\n\t/**\n\t* additive alpha blending\n\t*/\n\texport let BLEND_ADD_ALPHA: any\n\n\t/**\n\t* alpha blending\n\t*/\n\texport let BLEND_ALPHA: any\n\n\t/**\n\t* multiply blending\n\t*/\n\texport let BLEND_MULT: any\n\n\t/**\n\t* clipping mode none\n\t*/\n\texport let CLIPPING_MODE_NONE: any\n\n\t/**\n\t* clipping mode stencil\n\t*/\n\texport let CLIPPING_MODE_STENCIL: any\n\n\t/**\n\t* in-back\n\t*/\n\texport let EASING_INBACK: any\n\n\t/**\n\t* in-bounce\n\t*/\n\texport let EASING_INBOUNCE: any\n\n\t/**\n\t* in-circlic\n\t*/\n\texport let EASING_INCIRC: any\n\n\t/**\n\t* in-cubic\n\t*/\n\texport let EASING_INCUBIC: any\n\n\t/**\n\t* in-elastic\n\t*/\n\texport let EASING_INELASTIC: any\n\n\t/**\n\t* in-exponential\n\t*/\n\texport let EASING_INEXPO: any\n\n\t/**\n\t* in-out-back\n\t*/\n\texport let EASING_INOUTBACK: any\n\n\t/**\n\t* in-out-bounce\n\t*/\n\texport let EASING_INOUTBOUNCE: any\n\n\t/**\n\t* in-out-circlic\n\t*/\n\texport let EASING_INOUTCIRC: any\n\n\t/**\n\t* in-out-cubic\n\t*/\n\texport let EASING_INOUTCUBIC: any\n\n\t/**\n\t* in-out-elastic\n\t*/\n\texport let EASING_INOUTELASTIC: any\n\n\t/**\n\t* in-out-exponential\n\t*/\n\texport let EASING_INOUTEXPO: any\n\n\t/**\n\t* in-out-quadratic\n\t*/\n\texport let EASING_INOUTQUAD: any\n\n\t/**\n\t* in-out-quartic\n\t*/\n\texport let EASING_INOUTQUART: any\n\n\t/**\n\t* in-out-quintic\n\t*/\n\texport let EASING_INOUTQUINT: any\n\n\t/**\n\t* in-out-sine\n\t*/\n\texport let EASING_INOUTSINE: any\n\n\t/**\n\t* in-quadratic\n\t*/\n\texport let EASING_INQUAD: any\n\n\t/**\n\t* in-quartic\n\t*/\n\texport let EASING_INQUART: any\n\n\t/**\n\t* in-quintic\n\t*/\n\texport let EASING_INQUINT: any\n\n\t/**\n\t* in-sine\n\t*/\n\texport let EASING_INSINE: any\n\n\t/**\n\t* linear interpolation\n\t*/\n\texport let EASING_LINEAR: any\n\n\t/**\n\t* out-back\n\t*/\n\texport let EASING_OUTBACK: any\n\n\t/**\n\t* out-bounce\n\t*/\n\texport let EASING_OUTBOUNCE: any\n\n\t/**\n\t* out-circlic\n\t*/\n\texport let EASING_OUTCIRC: any\n\n\t/**\n\t* out-cubic\n\t*/\n\texport let EASING_OUTCUBIC: any\n\n\t/**\n\t* out-elastic\n\t*/\n\texport let EASING_OUTELASTIC: any\n\n\t/**\n\t* out-exponential\n\t*/\n\texport let EASING_OUTEXPO: any\n\n\t/**\n\t* out-in-back\n\t*/\n\texport let EASING_OUTINBACK: any\n\n\t/**\n\t* out-in-bounce\n\t*/\n\texport let EASING_OUTINBOUNCE: any\n\n\t/**\n\t* out-in-circlic\n\t*/\n\texport let EASING_OUTINCIRC: any\n\n\t/**\n\t* out-in-cubic\n\t*/\n\texport let EASING_OUTINCUBIC: any\n\n\t/**\n\t* out-in-elastic\n\t*/\n\texport let EASING_OUTINELASTIC: any\n\n\t/**\n\t* out-in-exponential\n\t*/\n\texport let EASING_OUTINEXPO: any\n\n\t/**\n\t* out-in-quadratic\n\t*/\n\texport let EASING_OUTINQUAD: any\n\n\t/**\n\t* out-in-quartic\n\t*/\n\texport let EASING_OUTINQUART: any\n\n\t/**\n\t* out-in-quintic\n\t*/\n\texport let EASING_OUTINQUINT: any\n\n\t/**\n\t* out-in-sine\n\t*/\n\texport let EASING_OUTINSINE: any\n\n\t/**\n\t* out-quadratic\n\t*/\n\texport let EASING_OUTQUAD: any\n\n\t/**\n\t* out-quartic\n\t*/\n\texport let EASING_OUTQUART: any\n\n\t/**\n\t* out-quintic\n\t*/\n\texport let EASING_OUTQUINT: any\n\n\t/**\n\t* out-sine\n\t*/\n\texport let EASING_OUTSINE: any\n\n\t/**\n\t* default keyboard\n\t*/\n\texport let KEYBOARD_TYPE_DEFAULT: any\n\n\t/**\n\t* email keyboard\n\t*/\n\texport let KEYBOARD_TYPE_EMAIL: any\n\n\t/**\n\t* number input keyboard\n\t*/\n\texport let KEYBOARD_TYPE_NUMBER_PAD: any\n\n\t/**\n\t* password keyboard\n\t*/\n\texport let KEYBOARD_TYPE_PASSWORD: any\n\n\t/**\n\t* elliptical pie node bounds\n\t*/\n\texport let PIEBOUNDS_ELLIPSE: any\n\n\t/**\n\t* rectangular pie node bounds\n\t*/\n\texport let PIEBOUNDS_RECTANGLE: any\n\n\t/**\n\t* center pivot\n\t*/\n\texport let PIVOT_CENTER: any\n\n\t/**\n\t* east pivot\n\t*/\n\texport let PIVOT_E: any\n\n\t/**\n\t* north pivot\n\t*/\n\texport let PIVOT_N: any\n\n\t/**\n\t* north-east pivot\n\t*/\n\texport let PIVOT_NE: any\n\n\t/**\n\t* north-west pivot\n\t*/\n\texport let PIVOT_NW: any\n\n\t/**\n\t* south pivot\n\t*/\n\texport let PIVOT_S: any\n\n\t/**\n\t* south-east pivot\n\t*/\n\texport let PIVOT_SE: any\n\n\t/**\n\t* south-west pivot\n\t*/\n\texport let PIVOT_SW: any\n\n\t/**\n\t* west pivot\n\t*/\n\texport let PIVOT_W: any\n\n\t/**\n\t* loop backward\n\t*/\n\texport let PLAYBACK_LOOP_BACKWARD: any\n\n\t/**\n\t* loop forward\n\t*/\n\texport let PLAYBACK_LOOP_FORWARD: any\n\n\t/**\n\t* ping pong loop\n\t*/\n\texport let PLAYBACK_LOOP_PINGPONG: any\n\n\t/**\n\t* once backward\n\t*/\n\texport let PLAYBACK_ONCE_BACKWARD: any\n\n\t/**\n\t* once forward\n\t*/\n\texport let PLAYBACK_ONCE_FORWARD: any\n\n\t/**\n\t* once forward and then backward\n\t*/\n\texport let PLAYBACK_ONCE_PINGPONG: any\n\n\t/**\n\t* color property\n\t*/\n\texport let PROP_COLOR: any\n\n\t/**\n\t* fill_angle property\n\t*/\n\texport let PROP_FILL_ANGLE: any\n\n\t/**\n\t* inner_radius property\n\t*/\n\texport let PROP_INNER_RADIUS: any\n\n\t/**\n\t* outline color property\n\t*/\n\texport let PROP_OUTLINE: any\n\n\t/**\n\t* position property\n\t*/\n\texport let PROP_POSITION: any\n\n\t/**\n\t* rotation property\n\t*/\n\texport let PROP_ROTATION: any\n\n\t/**\n\t* scale property\n\t*/\n\texport let PROP_SCALE: any\n\n\t/**\n\t* shadow color property\n\t*/\n\texport let PROP_SHADOW: any\n\n\t/**\n\t* size property\n\t*/\n\texport let PROP_SIZE: any\n\n\t/**\n\t* slice9 property\n\t*/\n\texport let PROP_SLICE9: any\n\n\t/**\n\t* data error\n\t*/\n\texport let RESULT_DATA_ERROR: any\n\n\t/**\n\t* out of resource\n\t*/\n\texport let RESULT_OUT_OF_RESOURCES: any\n\n\t/**\n\t* texture already exists\n\t*/\n\texport let RESULT_TEXTURE_ALREADY_EXISTS: any\n\n\t/**\n\t* automatic size mode\n\t*/\n\texport let SIZE_MODE_AUTO: any\n\n\t/**\n\t* manual size mode\n\t*/\n\texport let SIZE_MODE_MANUAL: any\n\n\t/**\n\t* This starts an animation of a node property according to the specified parameters.\n\t* If the node property is already being animated, that animation will be canceled and\n\t* replaced by the new one. Note however that several different node properties\n\t* can be animated simultaneously. Use `gui.cancel_animation` to stop the animation\n\t* before it has completed.\n\t* Composite properties of type vector3, vector4 or quaternion\n\t* also expose their sub-components (x, y, z and w).\n\t* You can address the components individually by suffixing the name with a dot \'.\'\n\t* and the name of the component.\n\t* For instance, `"position.x"` (the position x coordinate) or `"color.w"`\n\t* (the color alpha value).\n\t* If a `complete_function` (Lua function) is specified, that function will be called\n\t* when the animation has completed.\n\t* By starting a new animation in that function, several animations can be sequenced\n\t* together. See the examples below for more information.\n\t* @param node  node to animate\n\t* @param property  property to animate\n\n- `"position"`\n- `"rotation"`\n- `"scale"`\n- `"color"`\n- `"outline"`\n- `"shadow"`\n- `"size"`\n- `"fill_angle"` (pie)\n- `"inner_radius"` (pie)\n- `"slice9"` (slice9)\n\nThe following property constants are defined equaling the corresponding property string names.\n\n- `gui.PROP_POSITION`\n- `gui.PROP_ROTATION`\n- `gui.PROP_SCALE`\n- `gui.PROP_COLOR`\n- `gui.PROP_OUTLINE`\n- `gui.PROP_SHADOW`\n- `gui.PROP_SIZE`\n- `gui.PROP_FILL_ANGLE`\n- `gui.PROP_INNER_RADIUS`\n- `gui.PROP_SLICE9`\n\n\t* @param to  target property value\n\t* @param easing  easing to use during animation.\n     Either specify one of the `gui.EASING_*` constants or provide a\nwith a custom curve. See the animation guide for more information.\n\t* @param duration  duration of the animation in seconds.\n\t* @param delay  delay before the animation starts in seconds.\n\t* @param complete_function  function to call when the\n     animation has completed\n\t* @param playback  playback mode\n\n- `gui.PLAYBACK_ONCE_FORWARD`\n- `gui.PLAYBACK_ONCE_BACKWARD`\n- `gui.PLAYBACK_ONCE_PINGPONG`\n- `gui.PLAYBACK_LOOP_FORWARD`\n- `gui.PLAYBACK_LOOP_BACKWARD`\n- `gui.PLAYBACK_LOOP_PINGPONG`\n\n\t*/\n\texport function animate(node: node, property: any, to: vmath.vector3 | vmath.vector4, easing: any, duration: number, delay?: number, complete_function?: any, playback?: any): void\n\n\t/**\n\t* If an animation of the specified node is currently running (started by `gui.animate`), it will immediately be canceled.\n\t* @param node  node that should have its animation canceled\n\t* @param property  property for which the animation should be canceled\n\n- `"position"`\n- `"rotation"`\n- `"scale"`\n- `"color"`\n- `"outline"`\n- `"shadow"`\n- `"size"`\n- `"fill_angle"` (pie)\n- `"inner_radius"` (pie)\n- `"slice9"` (slice9)\n\n\t*/\n\texport function cancel_animation(node: node, property: any): void\n\n\t/**\n\t* Cancels any running flipbook animation on the specified node.\n\t* @param node  node cancel flipbook animation for\n\t*/\n\texport function cancel_flipbook(node: node): void\n\n\t/**\n\t* cancel a spine animation\n\t* @param node  spine node that should cancel its animation\n\t*/\n\texport function cancel_spine(node: node): void\n\n\t/**\n\t* Make a clone instance of a node.\n\t* This function does not clone the supplied node\'s children nodes.\n\t* Use gui.clone_tree for that purpose.\n\t* @param node  node to clone\n\t* @return clone  the cloned node\n\t*/\n\texport function clone(node: node): node\n\n\t/**\n\t* Make a clone instance of a node and all its children.\n\t* Use gui.clone to clone a node excluding its children.\n\t* @param node  root node to clone\n\t* @return clones  a table mapping node ids to the corresponding cloned nodes\n\t*/\n\texport function clone_tree(node: node): any\n\n\t/**\n\t* Deletes the specified node. Any child nodes of the specified node will be\n\t* recursively deleted.\n\t* @param node  node to delete\n\t*/\n\texport function delete_node(node: node): void\n\n\t/**\n\t* Delete a dynamically created texture.\n\t* @param texture  texture id\n\t*/\n\texport function delete_texture(texture: string | hash): void\n\n\t/**\n\t* Returns the adjust mode of a node.\n\t* The adjust mode defines how the node will adjust itself to screen\n\t* resolutions that differs from the one in the project settings.\n\t* @param node  node from which to get the adjust mode (node)\n\t* @return adjust_mode  the current adjust mode\n\n- `gui.ADJUST_FIT`\n- `gui.ADJUST_ZOOM`\n- `gui.ADJUST_STRETCH`\n\n\t*/\n\texport function get_adjust_mode(node: node): any\n\n\t/**\n\t* Returns the blend mode of a node.\n\t* Blend mode defines how the node will be blended with the background.\n\t* @param node  node from which to get the blend mode\n\t* @return blend_mode  blend mode\n\n- `gui.BLEND_ALPHA`\n- `gui.BLEND_ADD`\n- `gui.BLEND_ADD_ALPHA`\n- `gui.BLEND_MULT`\n\n\t*/\n\texport function get_blend_mode(node: node): any\n\n\t/**\n\t* If node is set as an inverted clipping node, it will clip anything inside as opposed to outside.\n\t* @param node  node from which to get the clipping inverted state\n\t* @return inverted  true or false\n\t*/\n\texport function get_clipping_inverted(node: node): boolean\n\n\t/**\n\t* Clipping mode defines how the node will clip it\'s children nodes\n\t* @param node  node from which to get the clipping mode\n\t* @return clipping_mode  clipping mode\n\n- `gui.CLIPPING_MODE_NONE`\n- `gui.CLIPPING_MODE_STENCIL`\n\n\t*/\n\texport function get_clipping_mode(node: node): any\n\n\t/**\n\t* If node is set as visible clipping node, it will be shown as well as clipping. Otherwise, it will only clip but not show visually.\n\t* @param node  node from which to get the clipping visibility state\n\t* @return visible  true or false\n\t*/\n\texport function get_clipping_visible(node: node): boolean\n\n\t/**\n\t* Returns the color of the supplied node. The components\n\t* of the returned vector4 contains the color channel values:\n\t* \n\t* \n\t* \n\t* Component\n\t* Color value\n\t* \n\t* \n\t* \n\t* \n\t* x\n\t* Red value\n\t* \n\t* \n\t* y\n\t* Green value\n\t* \n\t* \n\t* z\n\t* Blue value\n\t* \n\t* \n\t* w\n\t* Alpha value\n\t* \n\t* \n\t* \n\t* @param node  node to get the color from\n\t* @return color  node color\n\t*/\n\texport function get_color(node: node): vmath.vector4\n\n\t/**\n\t* Returns the sector angle of a pie node.\n\t* @param node  node from which to get the fill angle\n\t* @return angle  sector angle\n\t*/\n\texport function get_fill_angle(node: node): number\n\n\t/**\n\t* Get node flipbook animation.\n\t* @param node  node to get flipbook animation from\n\t* @return animation  animation id\n\t*/\n\texport function get_flipbook(node: node): hash\n\n\t/**\n\t* This is only useful nodes with flipbook animations. Gets the normalized cursor of the flipbook animation on a node.\n\t* @param node  node to get the cursor for (node)\n\t* @return cursor  cursor value\n\t*/\n\texport function get_flipbook_cursor(node: node): any\n\n\t/**\n\t* This is only useful nodes with flipbook animations. Gets the playback rate of the flipbook animation on a node.\n\t* @param node  node to set the cursor for\n\t* @return rate  playback rate\n\t*/\n\texport function get_flipbook_playback_rate(node: node): number\n\n\t/**\n\t* This is only useful for text nodes. The font must be mapped to the gui scene in the gui editor.\n\t* @param node  node from which to get the font\n\t* @return font  font id\n\t*/\n\texport function get_font(node: node): hash\n\n\t/**\n\t* Returns the scene height.\n\t* @return height  scene height\n\t*/\n\texport function get_height(): number\n\n\t/**\n\t* Retrieves the id of the specified node.\n\t* @param node  the node to retrieve the id from\n\t* @return id  the id of the node\n\t*/\n\texport function get_id(node: node): hash\n\n\t/**\n\t* Retrieve the index of the specified node among its siblings.\n\t* The index defines the order in which a node appear in a GUI scene.\n\t* Higher index means the node is drawn on top of lower indexed nodes.\n\t* @param node  the node to retrieve the id from\n\t* @return index  the index of the node\n\t*/\n\texport function get_index(node: node): number\n\n\t/**\n\t* gets the node inherit alpha state\n\t* @param node  node from which to get the inherit alpha state\n\t*/\n\texport function get_inherit_alpha(node: node): void\n\n\t/**\n\t* Returns the inner radius of a pie node.\n\t* The radius is defined along the x-axis.\n\t* @param node  node from where to get the inner radius\n\t* @return radius  inner radius\n\t*/\n\texport function get_inner_radius(node: node): number\n\n\t/**\n\t* The layer must be mapped to the gui scene in the gui editor.\n\t* @param node  node from which to get the layer\n\t* @return layer  layer id\n\t*/\n\texport function get_layer(node: node): hash\n\n\t/**\n\t* gets the scene current layout\n\t* @return layout  layout id\n\t*/\n\texport function get_layout(): hash\n\n\t/**\n\t* Returns the leading value for a text node.\n\t* @param node  node from where to get the leading\n\t* @return leading  leading scaling value (default=1)\n\t*/\n\texport function get_leading(node: node): number\n\n\t/**\n\t* Returns whether a text node is in line-break mode or not.\n\t* This is only useful for text nodes.\n\t* @param node  node from which to get the line-break for\n\t* @return line_break  `true` or `false`\n\t*/\n\texport function get_line_break(node: node): boolean\n\n\t/**\n\t* Retrieves the node with the specified id.\n\t* @param id  id of the node to retrieve\n\t* @return instance  a new node instance\n\t*/\n\texport function get_node(id: string | hash): node\n\n\t/**\n\t* Returns the outer bounds mode for a pie node.\n\t* @param node  node from where to get the outer bounds mode\n\t* @return bounds_mode  the outer bounds mode of the pie node:\n\n- `gui.PIEBOUNDS_RECTANGLE`\n- `gui.PIEBOUNDS_ELLIPSE`\n\n\t*/\n\texport function get_outer_bounds(node: node): any\n\n\t/**\n\t* Returns the outline color of the supplied node.\n\t* See gui.get_color for info how vectors encode color values.\n\t* @param node  node to get the outline color from\n\t* @return color  outline color\n\t*/\n\texport function get_outline(node: node): vmath.vector4\n\n\t/**\n\t* Returns the parent node of the specified node.\n\t* If the supplied node does not have a parent, `nil` is returned.\n\t* @param node  the node from which to retrieve its parent\n\t* @return parent  parent instance or nil\n\t*/\n\texport function get_parent(node: node): node\n\n\t/**\n\t* Get the paricle fx for a gui node\n\t* @param node  node to get particle fx for\n\t* @return   particle fx id\n\t*/\n\texport function get_particlefx(node: node): hash\n\n\t/**\n\t* Returns the number of generated vertices around the perimeter\n\t* of a pie node.\n\t* @param node  pie node\n\t* @return vertices  vertex count\n\t*/\n\texport function get_perimeter_vertices(node: node): number\n\n\t/**\n\t* The pivot specifies how the node is drawn and rotated from its position.\n\t* @param node  node to get pivot from\n\t* @return pivot  pivot constant\n\n- `gui.PIVOT_CENTER`\n- `gui.PIVOT_N`\n- `gui.PIVOT_NE`\n- `gui.PIVOT_E`\n- `gui.PIVOT_SE`\n- `gui.PIVOT_S`\n- `gui.PIVOT_SW`\n- `gui.PIVOT_W`\n- `gui.PIVOT_NW`\n\n\t*/\n\texport function get_pivot(node: node): any\n\n\t/**\n\t* Returns the position of the supplied node.\n\t* @param node  node to get the position from\n\t* @return position  node position\n\t*/\n\texport function get_position(node: node): vmath.vector3\n\n\t/**\n\t* Returns the rotation of the supplied node.\n\t* The rotation is expressed in degree Euler angles.\n\t* @param node  node to get the rotation from\n\t* @return rotation  node rotation\n\t*/\n\texport function get_rotation(node: node): vmath.vector3\n\n\t/**\n\t* Returns the scale of the supplied node.\n\t* @param node  node to get the scale from\n\t* @return scale  node scale\n\t*/\n\texport function get_scale(node: node): vmath.vector3\n\n\t/**\n\t* Returns the screen position of the supplied node. This function returns the\n\t* calculated transformed position of the node, taking into account any parent node\n\t* transforms.\n\t* @param node  node to get the screen position from\n\t* @return position  node screen position\n\t*/\n\texport function get_screen_position(node: node): vmath.vector3\n\n\t/**\n\t* Returns the shadow color of the supplied node.\n\t* See gui.get_color for info how vectors encode color values.\n\t* @param node  node to get the shadow color from\n\t* @return color  node shadow color\n\t*/\n\texport function get_shadow(node: node): vmath.vector4\n\n\t/**\n\t* Returns the size of the supplied node.\n\t* @param node  node to get the size from\n\t* @return size  node size\n\t*/\n\texport function get_size(node: node): vmath.vector3\n\n\t/**\n\t* Returns the size of a node.\n\t* The size mode defines how the node will adjust itself in size. Automatic\n\t* size mode alters the node size based on the node\'s content. Automatic size\n\t* mode works for Box nodes and Pie nodes which will both adjust their size\n\t* to match the assigned image. Spine, Particle fx and Text nodes will ignore\n\t* any size mode setting.\n\t* @param node  node from which to get the size mode (node)\n\t* @return size_mode  the current size mode\n\n- `gui.SIZE_MODE_MANUAL`\n- `gui.SIZE_MODE_AUTO`\n\n\t*/\n\texport function get_size_mode(node: node): any\n\n\t/**\n\t* Returns the slice9 configuration values for the node.\n\t* @param node  node to manipulate\n\t* @return values  configuration values\n\t*/\n\texport function get_slice9(node: node): vmath.vector4\n\n\t/**\n\t* Gets the playing animation on a spine node\n\t* @param node  node to get spine skin from\n\t* @return id  spine animation id, 0 if no animation is playing\n\t*/\n\texport function get_spine_animation(node: node): hash\n\n\t/**\n\t* The returned node can be used for parenting and transform queries.\n\t* This function has complexity O(n), where n is the number of bones in the spine model skeleton.\n\t* @param node  spine node to query for bone node\n\t* @param bone_id  id of the corresponding bone\n\t* @return bone  node corresponding to the spine bone\n\t*/\n\texport function get_spine_bone(node: node, bone_id: string | hash): node\n\n\t/**\n\t* This is only useful for spine nodes. Gets the normalized cursor of the animation on a spine node.\n\t* @param node  spine node to get the cursor for (node)\n\t* @return cursor  cursor value\n\t*/\n\texport function get_spine_cursor(node: node): any\n\n\t/**\n\t* This is only useful for spine nodes. Gets the playback rate of the animation on a spine node.\n\t* @param node  spine node to set the cursor for\n\t* @return rate  playback rate\n\t*/\n\texport function get_spine_playback_rate(node: node): number\n\n\t/**\n\t* Returns the spine scene id of the supplied node.\n\t* This is currently only useful for spine nodes.\n\t* The returned spine scene must be mapped to the gui scene in the gui editor.\n\t* @param node  node to get texture from\n\t* @return spine_scene  spine scene id\n\t*/\n\texport function get_spine_scene(node: node): hash\n\n\t/**\n\t* Gets the spine skin of a spine node\n\t* @param node  node to get spine skin from\n\t* @return id  spine skin id, 0 if no explicit skin is set\n\t*/\n\texport function get_spine_skin(node: node): hash\n\n\t/**\n\t* Returns the text value of a text node. This is only useful for text nodes.\n\t* @param node  node from which to get the text\n\t* @return text  text value\n\t*/\n\texport function get_text(node: node): string\n\n\t/**\n\t* Get text metrics given the provided font, text and parameters.\n\t* @param font  font id\n\t* @param text  text to measure\n\t* @param width  max-width. Use for line-breaks (default=FLT_MAX)\n\t* @param line_break  true to break lines accordingly to width (default=false)\n\t* @param leading  scale value for line spacing (default=1)\n\t* @param tracking  scale value for letter spacing (default=0)\n\t* @return metrics  a table with the following fields:\n\n- width\n- height\n- max_ascent\n- max_descent\n\n\t*/\n\texport function get_text_metrics(font: string | hash, text: string, width: number, line_break: boolean, leading: number, tracking: number): any\n\n\t/**\n\t* Get the text metrics from a text node.\n\t* @param node  text node to measure text from\n\t* @return metrics  a table with the following fields:\n\n- width\n- height\n- max_ascent\n- max_descent\n\n\t*/\n\texport function get_text_metrics_from_node(node: node): any\n\n\t/**\n\t* Returns the texture of a node.\n\t* This is currently only useful for box or pie nodes.\n\t* The texture must be mapped to the gui scene in the gui editor.\n\t* @param node  node to get texture from\n\t* @return texture  texture id\n\t*/\n\texport function get_texture(node: node): hash\n\n\t/**\n\t* Returns the tracking value of a text node.\n\t* @param node  node from where to get the tracking\n\t* @return tracking  tracking scaling number (default=0)\n\t*/\n\texport function get_tracking(node: node): number\n\n\t/**\n\t* Returns the scene width.\n\t* @return width  scene width\n\t*/\n\texport function get_width(): number\n\n\t/**\n\t* The x-anchor specifies how the node is moved when the game is run in a different resolution.\n\t* @param node  node to get x-anchor from\n\t* @return anchor  anchor constant\n\n- `gui.ANCHOR_NONE`\n- `gui.ANCHOR_LEFT`\n- `gui.ANCHOR_RIGHT`\n\n\t*/\n\texport function get_xanchor(node: node): any\n\n\t/**\n\t* The y-anchor specifies how the node is moved when the game is run in a different resolution.\n\t* @param node  node to get y-anchor from\n\t* @return anchor  anchor constant\n\n- `gui.ANCHOR_NONE`\n- `gui.ANCHOR_TOP`\n- `gui.ANCHOR_BOTTOM`\n\n\t*/\n\texport function get_yanchor(node: node): any\n\n\t/**\n\t* Hides the on-display touch keyboard on the device.\n\t*/\n\texport function hide_keyboard(): void\n\n\t/**\n\t* Returns `true` if a node is enabled and `false` if it\'s not.\n\t* Disabled nodes are not rendered and animations acting on them are not evaluated.\n\t* @param node  node to query\n\t* @param recursive  check hierarchy recursively\n\t* @return enabled  whether the node is enabled or not\n\t*/\n\texport function is_enabled(node: node, recursive: boolean): boolean\n\n\t/**\n\t* Alters the ordering of the two supplied nodes by moving the first node\n\t* above the second.\n\t* If the second argument is `nil` the first node is moved to the top.\n\t* @param node  to move\n\t* @param node  reference node above which the first node should be moved\n\t*/\n\texport function move_above(node: node, node1: any): void\n\n\t/**\n\t* Alters the ordering of the two supplied nodes by moving the first node\n\t* below the second.\n\t* If the second argument is `nil` the first node is moved to the bottom.\n\t* @param node  to move\n\t* @param node  reference node below which the first node should be moved\n\t*/\n\texport function move_below(node: node, node1: any): void\n\n\t/**\n\t* Dynamically create a new box node.\n\t* @param pos  node position\n\t* @param size  node size\n\t* @return node  new box node\n\t*/\n\texport function new_box_node(pos: vmath.vector3 | vmath.vector4, size: vmath.vector3): node\n\n\t/**\n\t* Dynamically create a particle fx node.\n\t* @param pos  node position\n\t* @param particlefx  particle fx resource name\n\t* @return node  new particle fx node\n\t*/\n\texport function new_particlefx_node(pos: vmath.vector3 | vmath.vector4, particlefx: hash | string): node\n\n\t/**\n\t* Dynamically create a new pie node.\n\t* @param pos  node position\n\t* @param size  node size\n\t* @return node  new pie node\n\t*/\n\texport function new_pie_node(pos: vmath.vector3 | vmath.vector4, size: vmath.vector3): node\n\n\t/**\n\t* Dynamically create a new spine node.\n\t* @param pos  node position\n\t* @param spine_scene  spine scene id\n\t* @return node  new spine node\n\t*/\n\texport function new_spine_node(pos: vmath.vector3 | vmath.vector4, spine_scene: string | hash): node\n\n\t/**\n\t* Dynamically create a new text node.\n\t* @param pos  node position\n\t* @param text  node text\n\t* @return node  new text node\n\t*/\n\texport function new_text_node(pos: vmath.vector3 | vmath.vector4, text: string): node\n\n\t/**\n\t* Dynamically create a new texture.\n\t* @param texture  texture id\n\t* @param width  texture width\n\t* @param height  texture height\n\t* @param type  texture type\n\n- `"rgb"` - RGB\n- `"rgba"` - RGBA\n- `"l"` - LUMINANCE\n\n\t* @param buffer  texture data\n\t* @param flip  flip texture vertically\n\t* @return success  texture creation was successful\n\t* @return code  one of the gui.RESULT_* codes if unsuccessful\n\t*/\n\texport function new_texture(texture: string | hash, width: number, height: number, type: any, buffer: string, flip: boolean): LuaMultiReturn<[boolean, number]>\n\n\t/**\n\t* Tests whether a coordinate is within the bounding box of a\n\t* node.\n\t* @param node  node to be tested for picking\n\t* @param x  x-coordinate (see on_input )\n\t* @param y  y-coordinate (see on_input )\n\t* @return pickable  pick result\n\t*/\n\texport function pick_node(node: node, x: number, y: number): boolean\n\n\t/**\n\t* Play flipbook animation on a box or pie node.\n\t* The current node texture must contain the animation.\n\t* Use this function to set one-frame still images on the node.\n\t* @param node  node to set animation for\n\t* @param animation  animation id\n\t* @param complete_function  optional function to call when the animation has completed\n\n`self`\n\nThe current object.\n\n`node`\n\nThe node that is animated.\n\n\n\t* @param play_properties  optional table with properties\n\n`offset`\nThe normalized initial value of the animation cursor when the animation starts playing\n`playback_rate`\nThe rate with which the animation will be played. Must be positive\n\n\t*/\n\texport function play_flipbook(node: node, animation: string | hash, complete_function?: any, play_properties?: any): void\n\n\t/**\n\t* Plays the paricle fx for a gui node\n\t* @param node  node to play particle fx for\n\t* @param emitter_state_function  optional callback function that will be called when an emitter attached to this particlefx changes state.\n\n`self`\nThe current object\n`node`\nThe particle fx node, or `nil` if the node was deleted\n`emitter`\nThe id of the emitter\n`state`\nthe new state of the emitter:\n\n\n- `particlefx.EMITTER_STATE_SLEEPING`\n- `particlefx.EMITTER_STATE_PRESPAWN`\n- `particlefx.EMITTER_STATE_SPAWNING`\n- `particlefx.EMITTER_STATE_POSTSPAWN`\n\n\t*/\n\texport function play_particlefx(node: node, emitter_state_function?: any): void\n\n\t/**\n\t* Starts a spine animation.\n\t* @param node  spine node that should play the animation\n\t* @param animation_id  id of the animation to play\n\t* @param playback  playback mode\n\n- `gui.PLAYBACK_ONCE_FORWARD`\n- `gui.PLAYBACK_ONCE_BACKWARD`\n- `gui.PLAYBACK_ONCE_PINGPONG`\n- `gui.PLAYBACK_LOOP_FORWARD`\n- `gui.PLAYBACK_LOOP_BACKWARD`\n- `gui.PLAYBACK_LOOP_PINGPONG`\n\n\t* @param play_properties  optional table with properties\n\n`blend_duration`\nThe duration of a linear blend between the current and new animation\n`offset`\nThe normalized initial value of the animation cursor when the animation starts playing\n`playback_rate`\nThe rate with which the animation will be played. Must be positive\n\n\t* @param complete_function  function to call when the animation has completed\n\t*/\n\texport function play_spine_anim(node: node, animation_id: string | hash, playback: any, play_properties?: any, complete_function?: any): void\n\n\t/**\n\t* Resets the input context of keyboard. This will clear marked text.\n\t*/\n\texport function reset_keyboard(): void\n\n\t/**\n\t* Resets all nodes in the current GUI scene to their initial state.\n\t* The reset only applies to static node loaded from the scene.\n\t* Nodes that are created dynamically from script are not affected.\n\t*/\n\texport function reset_nodes(): void\n\n\t/**\n\t* Sets the adjust mode on a node.\n\t* The adjust mode defines how the node will adjust itself to screen\n\t* resolutions that differs from the one in the project settings.\n\t* @param node  node to set adjust mode for\n\t* @param adjust_mode  adjust mode to set\n\n- `gui.ADJUST_FIT`\n- `gui.ADJUST_ZOOM`\n- `gui.ADJUST_STRETCH`\n\n\t*/\n\texport function set_adjust_mode(node: node, adjust_mode: any): void\n\n\t/**\n\t* Set the blend mode of a node.\n\t* Blend mode defines how the node will be blended with the background.\n\t* @param node  node to set blend mode for\n\t* @param blend_mode  blend mode to set\n\n- `gui.BLEND_ALPHA`\n- `gui.BLEND_ADD`\n- `gui.BLEND_ADD_ALPHA`\n- `gui.BLEND_MULT`\n\n\t*/\n\texport function set_blend_mode(node: node, blend_mode: any): void\n\n\t/**\n\t* If node is set as an inverted clipping node, it will clip anything inside as opposed to outside.\n\t* @param node  node to set clipping inverted state for\n\t* @param inverted  true or false\n\t*/\n\texport function set_clipping_inverted(node: node, inverted: boolean): void\n\n\t/**\n\t* Clipping mode defines how the node will clip it\'s children nodes\n\t* @param node  node to set clipping mode for\n\t* @param clipping_mode  clipping mode to set\n\n- `gui.CLIPPING_MODE_NONE`\n- `gui.CLIPPING_MODE_STENCIL`\n\n\t*/\n\texport function set_clipping_mode(node: node, clipping_mode: any): void\n\n\t/**\n\t* If node is set as an visible clipping node, it will be shown as well as clipping. Otherwise, it will only clip but not show visually.\n\t* @param node  node to set clipping visibility for\n\t* @param visible  true or false\n\t*/\n\texport function set_clipping_visible(node: node, visible: boolean): void\n\n\t/**\n\t* Sets the color of the supplied node. The components\n\t* of the supplied vector3 or vector4 should contain the color channel values:\n\t* \n\t* \n\t* \n\t* Component\n\t* Color value\n\t* \n\t* \n\t* \n\t* \n\t* x\n\t* Red value\n\t* \n\t* \n\t* y\n\t* Green value\n\t* \n\t* \n\t* z\n\t* Blue value\n\t* \n\t* \n\t* vector4\n\t* Alpha value\n\t* \n\t* \n\t* \n\t* @param node  node to set the color for\n\t* @param color  new color\n\t*/\n\texport function set_color(node: node, color: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Sets a node to the disabled or enabled state.\n\t* Disabled nodes are not rendered and animations acting on them are not evaluated.\n\t* @param node  node to be enabled/disabled\n\t* @param enabled  whether the node should be enabled or not\n\t*/\n\texport function set_enabled(node: node, enabled: boolean): void\n\n\t/**\n\t* Set the sector angle of a pie node.\n\t* @param node  node to set the fill angle for\n\t* @param angle  sector angle\n\t*/\n\texport function set_fill_angle(node: node, angle: number): void\n\n\t/**\n\t* This is only useful nodes with flipbook animations. The cursor is normalized.\n\t* @param node  node to set the cursor for\n\t* @param cursor  cursor value\n\t*/\n\texport function set_flipbook_cursor(node: node, cursor: number): void\n\n\t/**\n\t* This is only useful nodes with flipbook animations. Sets the playback rate of the flipbook animation on a node. Must be positive.\n\t* @param node  node to set the cursor for\n\t* @param playback_rate  playback rate\n\t*/\n\texport function set_flipbook_playback_rate(node: node, playback_rate: number): void\n\n\t/**\n\t* This is only useful for text nodes.\n\t* The font must be mapped to the gui scene in the gui editor.\n\t* @param node  node for which to set the font\n\t* @param font  font id\n\t*/\n\texport function set_font(node: node, font: string | hash): void\n\n\t/**\n\t* Set the id of the specicied node to a new value.\n\t* Nodes created with the gui.new_*_node() functions get\n\t* an empty id. This function allows you to give dynamically\n\t* created nodes an id.\n\t* ⚠ No checking is done on the uniqueness of supplied ids.\n\t* It is up to you to make sure you use unique ids.\n\t* @param node  node to set the id for\n\t* @param id  id to set\n\t*/\n\texport function set_id(node: node, id: string | hash): void\n\n\t/**\n\t* sets the node inherit alpha state\n\t* @param node  node from which to set the inherit alpha state\n\t* @param inherit_alpha  true or false\n\t*/\n\texport function set_inherit_alpha(node: node, inherit_alpha: boolean): void\n\n\t/**\n\t* Sets the inner radius of a pie node.\n\t* The radius is defined along the x-axis.\n\t* @param node  node to set the inner radius for\n\t* @param radius  inner radius\n\t*/\n\texport function set_inner_radius(node: node, radius: number): void\n\n\t/**\n\t* The layer must be mapped to the gui scene in the gui editor.\n\t* @param node  node for which to set the layer\n\t* @param layer  layer id\n\t*/\n\texport function set_layer(node: node, layer: string | hash): void\n\n\t/**\n\t* Sets the leading value for a text node. This value is used to\n\t* scale the line spacing of text.\n\t* @param node  node for which to set the leading\n\t* @param leading  a scaling value for the line spacing (default=1)\n\t*/\n\texport function set_leading(node: node, leading: number): void\n\n\t/**\n\t* Sets the line-break mode on a text node.\n\t* This is only useful for text nodes.\n\t* @param node  node to set line-break for\n\t* @param line_break  true or false\n\t*/\n\texport function set_line_break(node: node, line_break: boolean): void\n\n\t/**\n\t* Sets the outer bounds mode for a pie node.\n\t* @param node  node for which to set the outer bounds mode\n\t* @param bounds_mode  the outer bounds mode of the pie node:\n\n- `gui.PIEBOUNDS_RECTANGLE`\n- `gui.PIEBOUNDS_ELLIPSE`\n\n\t*/\n\texport function set_outer_bounds(node: node, bounds_mode: any): void\n\n\t/**\n\t* Sets the outline color of the supplied node.\n\t* See gui.set_color for info how vectors encode color values.\n\t* @param node  node to set the outline color for\n\t* @param color  new outline color\n\t*/\n\texport function set_outline(node: node, color: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Sets the parent node of the specified node.\n\t* @param node  node for which to set its parent\n\t* @param parent  parent node to set\n\t* @param keep_scene_transform  optional flag to make the scene position being perserved\n\t*/\n\texport function set_parent(node: node, parent: node, keep_scene_transform: boolean): void\n\n\t/**\n\t* Set the paricle fx for a gui node\n\t* @param node  node to set particle fx for\n\t* @param particlefx  particle fx id\n\t*/\n\texport function set_particlefx(node: node, particlefx: hash | string): void\n\n\t/**\n\t* Sets the number of generated vertices around the perimeter of a pie node.\n\t* @param node  pie node\n\t* @param vertices  vertex count\n\t*/\n\texport function set_perimeter_vertices(node: node, vertices: number): void\n\n\t/**\n\t* The pivot specifies how the node is drawn and rotated from its position.\n\t* @param node  node to set pivot for\n\t* @param pivot  pivot constant\n\n- `gui.PIVOT_CENTER`\n- `gui.PIVOT_N`\n- `gui.PIVOT_NE`\n- `gui.PIVOT_E`\n- `gui.PIVOT_SE`\n- `gui.PIVOT_S`\n- `gui.PIVOT_SW`\n- `gui.PIVOT_W`\n- `gui.PIVOT_NW`\n\n\t*/\n\texport function set_pivot(node: node, pivot: any): void\n\n\t/**\n\t* Sets the position of the supplied node.\n\t* @param node  node to set the position for\n\t* @param position  new position\n\t*/\n\texport function set_position(node: node, position: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Set the order number for the current GUI scene.\n\t* The number dictates the sorting of the "gui" render predicate,\n\t* in other words in which order the scene will be rendered in relation\n\t* to other currently rendered GUI scenes.\n\t* The number must be in the range 0 to 15.\n\t* @param order  rendering order (0-15)\n\t*/\n\texport function set_render_order(order: number): void\n\n\t/**\n\t* Sets the rotation of the supplied node.\n\t* The rotation is expressed in degree Euler angles.\n\t* @param node  node to set the rotation for\n\t* @param rotation  new rotation\n\t*/\n\texport function set_rotation(node: node, rotation: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Sets the scaling of the supplied node.\n\t* @param node  node to set the scale for\n\t* @param scale  new scale\n\t*/\n\texport function set_scale(node: node, scale: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Sets the shadow color of the supplied node.\n\t* See gui.set_color for info how vectors encode color values.\n\t* @param node  node to set the shadow color for\n\t* @param color  new shadow color\n\t*/\n\texport function set_shadow(node: node, color: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Sets the size of the supplied node.\n\t* ⚠ You can only set size on nodes with size mode set to SIZE_MODE_MANUAL\n\t* @param node  node to set the size for\n\t* @param size  new size\n\t*/\n\texport function set_size(node: node, size: vmath.vector3 | vmath.vector4): void\n\n\t/**\n\t* Sets the size mode of a node.\n\t* The size mode defines how the node will adjust itself in size. Automatic\n\t* size mode alters the node size based on the node\'s content. Automatic size\n\t* mode works for Box nodes and Pie nodes which will both adjust their size\n\t* to match the assigned image. Spine, Particle fx and Text nodes will ignore\n\t* any size mode setting.\n\t* @param node  node to set size mode for\n\t* @param size_mode  size mode to set\n\n- `gui.SIZE_MODE_MANUAL`\n- `gui.SIZE_MODE_AUTO`\n\n\t*/\n\texport function set_size_mode(node: node, size_mode: any): void\n\n\t/**\n\t* Set the slice9 configuration values for the node.\n\t* @param node  node to manipulate\n\t* @param values  new values\n\t*/\n\texport function set_slice9(node: node, values: vmath.vector4): void\n\n\t/**\n\t* This is only useful for spine nodes. The cursor is normalized.\n\t* @param node  spine node to set the cursor for\n\t* @param cursor  cursor value\n\t*/\n\texport function set_spine_cursor(node: node, cursor: number): void\n\n\t/**\n\t* This is only useful for spine nodes. Sets the playback rate of the animation on a spine node. Must be positive.\n\t* @param node  spine node to set the cursor for\n\t* @param playback_rate  playback rate\n\t*/\n\texport function set_spine_playback_rate(node: node, playback_rate: number): void\n\n\t/**\n\t* Set the spine scene on a spine node. The spine scene must be mapped to the gui scene in the gui editor.\n\t* @param node  node to set spine scene for\n\t* @param spine_scene  spine scene id\n\t*/\n\texport function set_spine_scene(node: node, spine_scene: string | hash): void\n\n\t/**\n\t* Sets the spine skin on a spine node.\n\t* @param node  node to set the spine skin on\n\t* @param spine_skin  spine skin id\n\t* @param spine_slot  optional slot id to only change a specific slot\n\t*/\n\texport function set_spine_skin(node: node, spine_skin: string | hash, spine_slot?: string | hash): void\n\n\t/**\n\t* Set the text value of a text node. This is only useful for text nodes.\n\t* @param node  node to set text for\n\t* @param text  text to set\n\t*/\n\texport function set_text(node: node, text: string): void\n\n\t/**\n\t* Set the texture on a box or pie node. The texture must be mapped to\n\t* the gui scene in the gui editor. The function points out which texture\n\t* the node should render from. If the texture is an atlas, further\n\t* information is needed to select which image/animation in the atlas\n\t* to render. In such cases, use `gui.play_flipbook()` in\n\t* addition to this function.\n\t* @param node  node to set texture for\n\t* @param texture  texture id\n\t*/\n\texport function set_texture(node: node, texture: string | hash): void\n\n\t/**\n\t* Set the texture buffer data for a dynamically created texture.\n\t* @param texture  texture id\n\t* @param width  texture width\n\t* @param height  texture height\n\t* @param type  texture type\n\n- `"rgb"` - RGB\n- `"rgba"` - RGBA\n- `"l"` - LUMINANCE\n\n\t* @param buffer  texture data\n\t* @param flip  flip texture vertically\n\t* @return success  setting the data was successful\n\t*/\n\texport function set_texture_data(texture: string | hash, width: number, height: number, type: any, buffer: string, flip: boolean): boolean\n\n\t/**\n\t* Sets the tracking value of a text node. This value is used to\n\t* adjust the vertical spacing of characters in the text.\n\t* @param node  node for which to set the tracking\n\t* @param tracking  a scaling number for the letter spacing (default=0)\n\t*/\n\texport function set_tracking(node: node, tracking: number): void\n\n\t/**\n\t* The x-anchor specifies how the node is moved when the game is run in a different resolution.\n\t* @param node  node to set x-anchor for\n\t* @param anchor  anchor constant\n\n- `gui.ANCHOR_NONE`\n- `gui.ANCHOR_LEFT`\n- `gui.ANCHOR_RIGHT`\n\n\t*/\n\texport function set_xanchor(node: node, anchor: any): void\n\n\t/**\n\t* The y-anchor specifies how the node is moved when the game is run in a different resolution.\n\t* @param node  node to set y-anchor for\n\t* @param anchor  anchor constant\n\n- `gui.ANCHOR_NONE`\n- `gui.ANCHOR_TOP`\n- `gui.ANCHOR_BOTTOM`\n\n\t*/\n\texport function set_yanchor(node: node, anchor: any): void\n\n\t/**\n\t* Shows the on-display touch keyboard.\n\t* The specified type of keyboard is displayed if it is available on\n\t* the device.\n\t* 🤖.\n\t* @param type  keyboard type\n\n- `gui.KEYBOARD_TYPE_DEFAULT`\n- `gui.KEYBOARD_TYPE_EMAIL`\n- `gui.KEYBOARD_TYPE_NUMBER_PAD`\n- `gui.KEYBOARD_TYPE_PASSWORD`\n\n\t* @param autoclose  if the keyboard should automatically close when clicking outside\n\t*/\n\texport function show_keyboard(type: any, autoclose: boolean): void\n\n\t/**\n\t* Stops the particle fx for a gui node\n\t* @param node  node to stop particle fx for\n\t*/\n\texport function stop_particlefx(node: node): void\n\n\n\t/**\n\t* This message is broadcast to every GUI component when a layout change has been initiated\n\t* on device.\n\t*/\n\texport type layout_changed = "layout_changed"\n\n\t/**\n\t* The material used when rendering the gui. The type of the property is hash.\n\t*/\n\texport let material: any\n\n\n\n\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace physics {\n\n\t/**\n\t* The angular damping value for the collision object. Setting this value alters the damping of\n\t* angular motion of the object (rotation). Valid values are between 0 (no damping) and 1 (full damping).\n\t*/\n\texport let angular_damping: any\n\n\t/**\n\t* vector3.\n\t* The velocity is measured as a rotation around the vector with a speed equivalent to the vector length\n\t* in radians/s.\n\t*/\n\texport let angular_velocity: any\n\n\t/**\n\t* Post this message to a collision-object-component to apply the specified force on the collision object.\n\t* The collision object must be dynamic.\n\t*/\n\texport type apply_force = "apply_force"\n\n\t/**\n\t* This message is broadcasted to every component of an instance that has a collision object,\n\t* when the collision object collides with another collision object. For a script to take action\n\t* when such a collision happens, it should check for this message in its `on_message` callback\n\t* function.\n\t* This message only reports that a collision actually happened and will only be sent once per\n\t* colliding pair and frame.\n\t* To retrieve more detailed information, check for the `contact_point_response` instead.\n\t*/\n\texport type collision_response = "collision_response"\n\n\t/**\n\t* This message is broadcasted to every component of an instance that has a collision object,\n\t* when the collision object has contact points with respect to another collision object.\n\t* For a script to take action when such contact points occur, it should check for this message\n\t* in its `on_message` callback function.\n\t* Since multiple contact points can occur for two colliding objects, this message can be sent\n\t* multiple times in the same frame for the same two colliding objects. To only be notified once\n\t* when the collision occurs, check for the `collision_response` message instead.\n\t*/\n\texport type contact_point_response = "contact_point_response"\n\n\t/**\n\t* The linear damping value for the collision object. Setting this value alters the damping of\n\t* linear motion of the object. Valid values are between 0 (no damping) and 1 (full damping).\n\t*/\n\texport let linear_damping: any\n\n\t/**\n\t* The current linear velocity of the collision object component as a vector3.\n\t* The velocity is measured in units/s (pixels/s).\n\t*/\n\texport let linear_velocity: any\n\n\t/**\n\t* READ ONLY Returns the defined physical mass of the collision object component as a number.\n\t*/\n\texport let mass: any\n\n\t/**\n\t* fixed joint type\n\t*/\n\texport let JOINT_TYPE_FIXED: any\n\n\t/**\n\t* hinge joint type\n\t*/\n\texport let JOINT_TYPE_HINGE: any\n\n\t/**\n\t* slider joint type\n\t*/\n\texport let JOINT_TYPE_SLIDER: any\n\n\t/**\n\t* spring joint type\n\t*/\n\texport let JOINT_TYPE_SPRING: any\n\n\t/**\n\t* weld joint type\n\t*/\n\texport let JOINT_TYPE_WELD: any\n\n\t/**\n\t* Create a physics joint between two collision object components.\n\t* Note: Currently only supported in 2D physics.\n\t* @param joint_type  the joint type\n\t* @param collisionobject_a  first collision object\n\t* @param joint_id  id of the joint\n\t* @param position_a  local position where to attach the joint on the first collision object\n\t* @param collisionobject_b  second collision object\n\t* @param position_b  local position where to attach the joint on the second collision object\n\t* @param properties  optional joint specific properties table\nSee each joint type for possible properties field. The one field that is accepted for all joint types is:\n`collide_connected`: Set this flag to true if the attached bodies should collide.\n\t*/\n\texport function create_joint(joint_type: number, collisionobject_a: string | hash | url, joint_id: string | hash, position_a: vmath.vector3, collisionobject_b: string | hash | url, position_b: vmath.vector3, properties?: any): void\n\n\t/**\n\t* Destroy an already physics joint. The joint has to be created before a\n\t* destroy can be issued.\n\t* Note: Currently only supported in 2D physics.\n\t* @param collisionobject  collision object where the joint exist\n\t* @param joint_id  id of the joint\n\t*/\n\texport function destroy_joint(collisionobject: string | hash | url, joint_id: string | hash): void\n\n\t/**\n\t* Get the gravity in runtime. The gravity returned is not global, it will return\n\t* the gravity for the collection that the function is called from.\n\t* Note: For 2D physics the z component will always be zero.\n\t* @return   gravity vector of collection\n\t*/\n\texport function get_gravity(): vmath.vector3\n\n\t/**\n\t* Get a table for properties for a connected joint. The joint has to be created before\n\t* properties can be retrieved.\n\t* Note: Currently only supported in 2D physics.\n\t* @param collisionobject  collision object where the joint exist\n\t* @param joint_id  id of the joint\n\t* @return   properties table. See the joint types for what fields are available, the only field available for all types is:\n\n`collide_connected`: Set this flag to true if the attached bodies should collide.\n\n\t*/\n\texport function get_joint_properties(collisionobject: string | hash | url, joint_id: string | hash): any\n\n\t/**\n\t* Get the reaction force for a joint. The joint has to be created before\n\t* the reaction force can be calculated.\n\t* Note: Currently only supported in 2D physics.\n\t* @param collisionobject  collision object where the joint exist\n\t* @param joint_id  id of the joint\n\t* @return force  reaction force for the joint\n\t*/\n\texport function get_joint_reaction_force(collisionobject: string | hash | url, joint_id: string | hash): vmath.vector3\n\n\t/**\n\t* Get the reaction torque for a joint. The joint has to be created before\n\t* the reaction torque can be calculated.\n\t* Note: Currently only supported in 2D physics.\n\t* @param collisionobject  collision object where the joint exist\n\t* @param joint_id  id of the joint\n\t* @return torque  the reaction torque on bodyB in N*m.\n\t*/\n\texport function get_joint_reaction_torque(collisionobject: string | hash | url, joint_id: string | hash): any\n\n\t/**\n\t* Ray casts are used to test for intersections against collision objects in the physics world.\n\t* Collision objects of types kinematic, dynamic and static are tested against. Trigger objects\n\t* do not intersect with ray casts.\n\t* Which collision objects to hit is filtered by their collision groups and can be configured\n\t* through `groups`.\n\t* @param from  the world position of the start of the ray\n\t* @param to  the world position of the end of the ray\n\t* @param groups  a lua table containing the hashed groups for which to test collisions against\n\t* @param options  a lua table containing options for the raycast.\n\n`all`\nSet to `true` to return all ray cast hits. If `false`, it will only return the closest hit.\n\n\t* @return result  It returns a list. If missed it returns nil. See `ray_cast_response` for details on the returned values.\n\t*/\n\texport function raycast(from: vmath.vector3, to: vmath.vector3, groups: any, options: any): any\n\n\t/**\n\t* Ray casts are used to test for intersections against collision objects in the physics world.\n\t* Collision objects of types kinematic, dynamic and static are tested against. Trigger objects\n\t* do not intersect with ray casts.\n\t* Which collision objects to hit is filtered by their collision groups and can be configured\n\t* through `groups`.\n\t* The actual ray cast will be performed during the physics-update.\n\t* \n\t* - If an object is hit, the result will be reported via a `ray_cast_response` message.\n\t* - If there is no object hit, the result will be reported via a `ray_cast_missed` message.\n\t* \n\t* @param from  the world position of the start of the ray\n\t* @param to  the world position of the end of the ray\n\t* @param groups  a lua table containing the hashed groups for which to test collisions against\n\t* @param request_id  . It will be sent back in the response for identification, 0 by default\n\t*/\n\texport function raycast_async(from: vmath.vector3, to: vmath.vector3, groups: any, request_id?: any): void\n\n\t/**\n\t* Set the gravity in runtime. The gravity change is not global, it will only affect\n\t* the collection that the function is called from.\n\t* Note: For 2D physics the z component of the gravity vector will be ignored.\n\t* @param gravity  the new gravity vector\n\t*/\n\texport function set_gravity(gravity: vmath.vector3): void\n\n\t/**\n\t* Flips the collision shapes horizontally for a collision object\n\t* @param url  the collision object that should flip its shapes\n\t* @param flip  `true` if the collision object should flip its shapes, `false` if not\n\t*/\n\texport function set_hflip(url: string | hash | url, flip: boolean): void\n\n\t/**\n\t* Updates the properties for an already connected joint. The joint has to be created before\n\t* properties can be changed.\n\t* Note: Currently only supported in 2D physics.\n\t* @param collisionobject  collision object where the joint exist\n\t* @param joint_id  id of the joint\n\t* @param properties  joint specific properties table\nNote: The `collide_connected` field cannot be updated/changed after a connection has been made.\n\t*/\n\texport function set_joint_properties(collisionobject: string | hash | url, joint_id: string | hash, properties: any): void\n\n\t/**\n\t* Flips the collision shapes vertically for a collision object\n\t* @param url  the collision object that should flip its shapes\n\t* @param flip  `true` if the collision object should flip its shapes, `false` if not\n\t*/\n\texport function set_vflip(url: string | hash | url, flip: boolean): void\n\n\t/**\n\t* Collision objects tend to fall asleep when inactive for a small period of time for\n\t* efficiency reasons. This function wakes them up.\n\t* @param url  the collision object to wake.\nfunction on_input(self, action_id, action)\n    if action_id == hash(&quot;test&quot;) and action.pressed then\n        physics.wakeup(&quot;#collisionobject&quot;)\n    end\nend\n\n\t*/\n\texport function wakeup(url: string | hash | url): void\n\n\t/**\n\t* This message is sent back to the sender of a `ray_cast_request`, if the ray didn\'t hit any\n\t* collision object. See `physics.raycast_async` for examples of how to use it.\n\t*/\n\texport type ray_cast_missed = "ray_cast_missed"\n\n\t/**\n\t* This message is sent back to the sender of a `ray_cast_request`, if the ray hit a\n\t* collision object. See `physics.raycast_async` for examples of how to use it.\n\t*/\n\texport type ray_cast_response = "ray_cast_response"\n\n\t/**\n\t* This message is broadcasted to every component of an instance that has a collision object,\n\t* when the collision object interacts with another collision object and one of them is a trigger.\n\t* For a script to take action when such an interaction happens, it should check for this message\n\t* in its `on_message` callback function.\n\t* This message only reports that an interaction actually happened and will only be sent once per\n\t* colliding pair and frame. To retrieve more detailed information, check for the\n\t* `contact_point_response` instead.\n\t*/\n\texport type trigger_response = "trigger_response"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace profiler {\n\n\t/**\n\t* pause on current frame\n\t*/\n\texport let MODE_PAUSE: any\n\n\t/**\n\t* start recording\n\t*/\n\texport let MODE_RECORD: any\n\n\t/**\n\t* continously show latest frame\n\t*/\n\texport let MODE_RUN: any\n\n\t/**\n\t* pause at peak frame\n\t*/\n\texport let MODE_SHOW_PEAK_FRAME: any\n\n\t/**\n\t* show full profiler ui\n\t*/\n\texport let VIEW_MODE_FULL: any\n\n\t/**\n\t* show mimimal profiler ui\n\t*/\n\texport let VIEW_MODE_MINIMIZED: any\n\n\t/**\n\t* Creates and shows or hides and destroys the on-sceen profiler ui\n\t* The profiler is a real-time tool that shows the numbers of milliseconds spent\n\t* in each scope per frame as well as counters. The profiler is very useful for\n\t* tracking down performance and resource problems.\n\t* @param enabled  true to enable, false to disable\n\t*/\n\texport function enable_ui(enabled: boolean): void\n\n\t/**\n\t* Get the percent of CPU usage by the application, as reported by the OS.\n\t* 🌎 HTML5.\n\t* 🌎 Windows), this information is only available\n\t* by default in the debug version of the engine. It can be enabled in release version as well\n\t* by checking `track_cpu` under `profiler` in the `game.project` file.\n\t* (This means that the engine will sample the CPU usage in intervalls during execution even in release mode.)\n\t* @return percent  of CPU used by the application\n\t*/\n\texport function get_cpu_usage(): number\n\n\t/**\n\t* Get the amount of memory used (resident/working set) by the application in bytes, as reported by the OS.\n\t* 🌎 HTML5.\n\t* The values are gathered from internal OS functions which correspond to the following;\n\t* \n\t* \n\t* \n\t* OS\n\t* Value\n\t* \n\t* \n\t* \n\t* \n\t* 🌎 Linux\n\t* Resident memory\n\t* \n\t* \n\t* 🌎 Windows\n\t* Working set\n\t* \n\t* \n\t* 🌎 HTML5\n\t* 🌎 Not available\n\t* \n\t* \n\t* \n\t* @return bytes  used by the application\n\t*/\n\texport function get_memory_usage(): number\n\n\t/**\n\t* Get the number of recorded frames in the on-screen profiler ui recording buffer\n\t* @return frame_count  the number of recorded frames, zero if on-screen profiler is disabled\n\t*/\n\texport function recorded_frame_count(): number\n\n\t/**\n\t* Set the on-screen profile mode - run, pause, record or show peak frame\n\t* @param mode  the mode to set the ui profiler in\n\n- `profiler.MODE_RUN` This is default mode that continously shows the last frame\n- `profiler.MODE_PAUSE` Pauses on the currently displayed frame\n- `profiler.MODE_SHOW_PEAK_FRAME` Pauses on the currently displayed frame but shows a new frame if that frame is slower\n- `profiler.MODE_RECORD` Records all incoming frames to the recording buffer\n\nTo stop recording, switch to a different mode such as `MODE_PAUSE` or `MODE_RUN`.\nYou can also use the `view_recorded_frame` function to display a recorded frame. Doing so stops the recording as well.\nEvery time you switch to recording mode the recording buffer is cleared.\nThe recording buffer is also cleared when setting the `MODE_SHOW_PEAK_FRAME` mode.\n\t*/\n\texport function set_ui_mode(mode: any): void\n\n\t/**\n\t* Set the on-screen profile view mode - minimized or expanded\n\t* @param mode  the view mode to set the ui profiler in\n\n- `profiler.VIEW_MODE_FULL` The default mode which displays all the ui profiler details\n- `profiler.VIEW_MODE_MINIMIZED` Minimized mode which only shows the top header (fps counters and ui profiler mode)\n\n\t*/\n\texport function set_ui_view_mode(mode: any): void\n\n\t/**\n\t* Shows or hides the time the engine waits for vsync in the on-screen profiler\n\t* Each frame the engine waits for vsync and depending on your vsync settings and how much time\n\t* your game logic takes this time can dwarf the time in the game logic making it hard to\n\t* see details in the on-screen profiler graph and lists.\n\t* Also, by hiding this the FPS times in the header show the time spent each time excuding the\n\t* time spent waiting for vsync. This shows you how long time your game is spending actively\n\t* working each frame.\n\t* This setting also effects the display of recorded frames but does not affect the actual\n\t* recorded frames so it is possible to toggle this on and off when viewing recorded frames.\n\t* By default the vsync wait times is displayed in the profiler.\n\t* @param visible  true to include it in the display, false to hide it.\n\t*/\n\texport function set_ui_vsync_wait_visible(visible: boolean): void\n\n\t/**\n\t* Pauses and displays a frame from the recording buffer in the on-screen profiler ui\n\t* The frame to show can either be an absolute frame or a relative frame to the current frame.\n\t* @param frame_index  a table where you specify one of the following parameters:\n\n- `distance` The offset from the currently displayed frame (this is truncated between zero and the number of recorded frames)\n- `frame` The frame index in the recording buffer (1 is first recorded frame)\n\n\t*/\n\texport function view_recorded_frame(frame_index: any): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace render {\n\n\t/**\n\t* Set render clear color. This is the color that appears on the screen where nothing is rendered, i.e. background.\n\t*/\n\texport type clear_color = "clear_color"\n\n\t/**\n\t* Draw a text on the screen. This should be used for debugging purposes only.\n\t*/\n\texport type draw_debug_text = "draw_debug_text"\n\n\t/**\n\t* Draw a line on the screen. This should mostly be used for debugging purposes.\n\t*/\n\texport type draw_line = "draw_line"\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_CONSTANT_ALPHA: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_CONSTANT_COLOR: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_DST_ALPHA: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_DST_COLOR: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE_MINUS_CONSTANT_ALPHA: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE_MINUS_CONSTANT_COLOR: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE_MINUS_DST_ALPHA: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE_MINUS_DST_COLOR: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE_MINUS_SRC_ALPHA: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ONE_MINUS_SRC_COLOR: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_SRC_ALPHA: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_SRC_ALPHA_SATURATE: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_SRC_COLOR: any\n\n\t/**\n\t* \n\t*/\n\texport let BLEND_ZERO: any\n\n\t/**\n\t* \n\t*/\n\texport let BUFFER_COLOR_BIT: any\n\n\t/**\n\t* \n\t*/\n\texport let BUFFER_DEPTH_BIT: any\n\n\t/**\n\t* \n\t*/\n\texport let BUFFER_STENCIL_BIT: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_ALWAYS: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_EQUAL: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_GEQUAL: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_GREATER: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_LEQUAL: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_LESS: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_NEVER: any\n\n\t/**\n\t* \n\t*/\n\texport let COMPARE_FUNC_NOTEQUAL: any\n\n\t/**\n\t* \n\t*/\n\texport let FACE_BACK: any\n\n\t/**\n\t* \n\t*/\n\texport let FACE_FRONT: any\n\n\t/**\n\t* \n\t*/\n\texport let FACE_FRONT_AND_BACK: any\n\n\t/**\n\t* \n\t*/\n\texport let FILTER_LINEAR: any\n\n\t/**\n\t* \n\t*/\n\texport let FILTER_NEAREST: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_DEPTH: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_LUMINANCE: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_RGB: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_RGBA: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_RGBA_DXT1: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_RGBA_DXT3: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_RGBA_DXT5: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_RGB_DXT1: any\n\n\t/**\n\t* \n\t*/\n\texport let FORMAT_STENCIL: any\n\n\t/**\n\t* \n\t*/\n\texport let RENDER_TARGET_DEFAULT: any\n\n\t/**\n\t* \n\t*/\n\texport let STATE_BLEND: any\n\n\t/**\n\t* \n\t*/\n\texport let STATE_CULL_FACE: any\n\n\t/**\n\t* \n\t*/\n\texport let STATE_DEPTH_TEST: any\n\n\t/**\n\t* \n\t*/\n\texport let STATE_POLYGON_OFFSET_FILL: any\n\n\t/**\n\t* \n\t*/\n\texport let STATE_STENCIL_TEST: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_DECR: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_DECR_WRAP: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_INCR: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_INCR_WRAP: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_INVERT: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_KEEP: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_REPLACE: any\n\n\t/**\n\t* \n\t*/\n\texport let STENCIL_OP_ZERO: any\n\n\t/**\n\t* \n\t*/\n\texport let WRAP_CLAMP_TO_BORDER: any\n\n\t/**\n\t* \n\t*/\n\texport let WRAP_CLAMP_TO_EDGE: any\n\n\t/**\n\t* \n\t*/\n\texport let WRAP_MIRRORED_REPEAT: any\n\n\t/**\n\t* \n\t*/\n\texport let WRAP_REPEAT: any\n\n\t/**\n\t* Clear buffers in the currently enabled render target with specified value.\n\t* @param buffers  table with keys specifying which buffers to clear and values set to clear values. Available keys are:\n\n- `render.BUFFER_COLOR_BIT`\n- `render.BUFFER_DEPTH_BIT`\n- `render.BUFFER_STENCIL_BIT`\n\n\t*/\n\texport function clear(buffers: any): void\n\n\t/**\n\t* Constant buffers are used to set shader program variables and are optionally passed to the `render.draw()` function. The buffer\'s constant elements can be indexed like an ordinary Lua table, but you can\'t iterate over them with pairs() or ipairs().\n\t* @return buffer  new constant buffer\n\t*/\n\texport function constant_buffer(): any\n\n\t/**\n\t* Deletes a previously created render target.\n\t* @param render_target  render target to delete\n\t*/\n\texport function delete_render_target(render_target: any): void\n\n\t/**\n\t* If a material is currently enabled, disable it.\n\t* The name of the material must be specified in the ".render" resource set\n\t* in the "game.project" setting.\n\t*/\n\texport function disable_material(): void\n\n\t/**\n\t* Disables a render state.\n\t* @param state  state to disable\n\n- `render.STATE_DEPTH_TEST`\n- `render.STATE_STENCIL_TEST`\n- `render.STATE_BLEND`\n🤖 not available on iOS and Android)\n- `render.STATE_CULL_FACE`\n- `render.STATE_POLYGON_OFFSET_FILL`\n\n\t*/\n\texport function disable_state(state: any): void\n\n\t/**\n\t* Disables a texture unit for a render target that has previourly been enabled.\n\t* @param unit  texture unit to disable\n\t*/\n\texport function disable_texture(unit: number): void\n\n\t/**\n\t* Draws all objects that match a specified predicate. An optional constant buffer can be\n\t* provided to override the default constants. If no constants buffer is provided, a default\n\t* system constants buffer is used containing constants as defined in materials and set through\n\t* go.set (or particlefx.set_constant) on visual components.\n\t* @param predicate  predicate to draw for\n\t* @param constants  optional constants to use while rendering\n\t*/\n\texport function draw(predicate: any, constants?: any): void\n\n\t/**\n\t* Draws all 3d debug graphics such as lines drawn with "draw_line" messages and physics visualization.\n\t*/\n\texport function draw_debug3d(): void\n\n\t/**\n\t* If another material was already enabled, it will be automatically disabled\n\t* and the specified material is used instead.\n\t* The name of the material must be specified in the ".render" resource set\n\t* in the "game.project" setting.\n\t* @param material_id  material id to enable\n\t*/\n\texport function enable_material(material_id: string | hash): void\n\n\t/**\n\t* Enables a particular render state. The state will be enabled until disabled.\n\t* @param state  state to enable\n\n- `render.STATE_DEPTH_TEST`\n- `render.STATE_STENCIL_TEST`\n- `render.STATE_BLEND`\n🤖 not available on iOS and Android)\n- `render.STATE_CULL_FACE`\n- `render.STATE_POLYGON_OFFSET_FILL`\n\n\t*/\n\texport function enable_state(state: any): void\n\n\t/**\n\t* Sets the specified render target\'s specified buffer to be\n\t* used as texture with the specified unit.\n\t* A material shader can then use the texture to sample from.\n\t* @param unit  texture unit to enable texture for\n\t* @param render_target  render target from which to enable the specified texture unit\n\t* @param buffer_type  buffer type from which to enable the texture\n\n- `render.BUFFER_COLOR_BIT`\n- `render.BUFFER_DEPTH_BIT`\n- `render.BUFFER_STENCIL_BIT`\n\n\t*/\n\texport function enable_texture(unit: number, render_target: any, buffer_type: any): void\n\n\t/**\n\t* Returns the logical window height that is set in the "game.project" settings.\n\t* Note that the actual window pixel size can change, either by device constraints\n\t* or user input.\n\t* @return height  specified window height\n\t*/\n\texport function get_height(): number\n\n\t/**\n\t* Returns the specified buffer height from a render target.\n\t* @param render_target  render target from which to retrieve the buffer height\n\t* @param buffer_type  which type of buffer to retrieve the height from\n\n- `render.BUFFER_COLOR_BIT`\n- `render.BUFFER_DEPTH_BIT`\n- `render.BUFFER_STENCIL_BIT`\n\n\t* @return height  the height of the render target buffer texture\n\t*/\n\texport function get_render_target_height(render_target: any, buffer_type: any): number\n\n\t/**\n\t* Returns the specified buffer width from a render target.\n\t* @param render_target  render target from which to retrieve the buffer width\n\t* @param buffer_type  which type of buffer to retrieve the width from\n\n- `render.BUFFER_COLOR_BIT`\n- `render.BUFFER_DEPTH_BIT`\n- `render.BUFFER_STENCIL_BIT`\n\n\t* @return width  the width of the render target buffer texture\n\t*/\n\texport function get_render_target_width(render_target: any, buffer_type: any): number\n\n\t/**\n\t* Returns the logical window width that is set in the "game.project" settings.\n\t* Note that the actual window pixel size can change, either by device constraints\n\t* or user input.\n\t* @return width  specified window width (number)\n\t*/\n\texport function get_width(): number\n\n\t/**\n\t* Returns the actual physical window height.\n\t* Note that this value might differ from the logical height that is set in the\n\t* "game.project" settings.\n\t* @return height  actual window height\n\t*/\n\texport function get_window_height(): number\n\n\t/**\n\t* Returns the actual physical window width.\n\t* Note that this value might differ from the logical width that is set in the\n\t* "game.project" settings.\n\t* @return width  actual window width\n\t*/\n\texport function get_window_width(): number\n\n\t/**\n\t* This function returns a new render predicate for objects with materials matching\n\t* the provided material tags. The provided tags are combined into a bit mask\n\t* for the predicate. If multiple tags are provided, the predicate matches materials\n\t* with all tags ANDed together.\n\t* The current limit to the number of tags that can be defined is `64`.\n\t* @param tags  table of tags that the predicate should match. The tags can be of either hash or string type\n\t* @return predicate  new predicate\n\t*/\n\texport function predicate(tags: any): any\n\n\t/**\n\t* Creates a new render target according to the supplied\n\t* specification table.\n\t* The table should contain keys specifying which buffers should be created\n\t* with what parameters. Each buffer key should have a table value consisting\n\t* of parameters. The following parameter keys are available:\n\t* \n\t* \n\t* \n\t* Key\n\t* Values\n\t* \n\t* \n\t* \n\t* \n\t* `format`\n\t* `render.FORMAT_LUMINANCE``render.FORMAT_RGB``render.FORMAT_RGBA` `render.FORMAT_RGB_DXT1``render.FORMAT_RGBA_DXT1``render.FORMAT_RGBA_DXT3` `render.FORMAT_RGBA_DXT5``render.FORMAT_DEPTH``render.FORMAT_STENCIL`\n\t* \n\t* \n\t* `width`\n\t* number\n\t* \n\t* \n\t* `height`\n\t* number\n\t* \n\t* \n\t* `min_filter`\n\t* `render.FILTER_LINEAR``render.FILTER_NEAREST`\n\t* \n\t* \n\t* `mag_filter`\n\t* `render.FILTER_LINEAR``render.FILTER_NEAREST`\n\t* \n\t* \n\t* `u_wrap`\n\t* `render.WRAP_CLAMP_TO_BORDER``render.WRAP_CLAMP_TO_EDGE``render.WRAP_MIRRORED_REPEAT``render.WRAP_REPEAT`\n\t* \n\t* \n\t* `v_wrap`\n\t* `render.WRAP_CLAMP_TO_BORDER``render.WRAP_CLAMP_TO_EDGE``render.WRAP_MIRRORED_REPEAT``render.WRAP_REPEAT`\n\t* \n\t* \n\t* \n\t* @param name  render target name\n\t* @param parameters  table of buffer parameters, see the description for available keys and values\n\t* @return render_target  new render target\n\t*/\n\texport function render_target(name: string, parameters: any): any\n\n\t/**\n\t* Specifies the arithmetic used when computing pixel values that are written to the frame\n\t* buffer. In RGBA mode, pixels can be drawn using a function that blends the source RGBA\n\t* pixel values with the destination pixel values already in the frame buffer.\n\t* Blending is initially disabled.\n\t* `source_factor` specifies which method is used to scale the source color components.\n\t* `destination_factor` specifies which method is used to scale the destination color\n\t* components.\n\t* Source color components are referred to as (Rs,Gs,Bs,As).\n\t* Destination color components are referred to as (Rd,Gd,Bd,Ad).\n\t* The color specified by setting the blendcolor is referred to as (Rc,Gc,Bc,Ac).\n\t* The source scale factor is referred to as (sR,sG,sB,sA).\n\t* The destination scale factor is referred to as (dR,dG,dB,dA).\n\t* The color values have integer values between 0 and (kR,kG,kB,kA), where kc = 2mc - 1 and mc is the number of bitplanes for that color. I.e for 8 bit color depth, color values are between `0` and `255`.\n\t* Available factor constants and corresponding scale factors:\n\t* \n\t* \n\t* \n\t* Factor constant\n\t* Scale factor (fR,fG,fB,fA)\n\t* \n\t* \n\t* \n\t* \n\t* `render.BLEND_ZERO`\n\t* (0,0,0,0)\n\t* \n\t* \n\t* `render.BLEND_ONE`\n\t* (1,1,1,1)\n\t* \n\t* \n\t* `render.BLEND_SRC_COLOR`\n\t* (Rs/kR,Gs/kG,Bs/kB,As/kA)\n\t* \n\t* \n\t* `render.BLEND_ONE_MINUS_SRC_COLOR`\n\t* (1,1,1,1) - (Rs/kR,Gs/kG,Bs/kB,As/kA)\n\t* \n\t* \n\t* `render.BLEND_DST_COLOR`\n\t* (Rd/kR,Gd/kG,Bd/kB,Ad/kA)\n\t* \n\t* \n\t* `render.BLEND_ONE_MINUS_DST_COLOR`\n\t* (1,1,1,1) - (Rd/kR,Gd/kG,Bd/kB,Ad/kA)\n\t* \n\t* \n\t* `render.BLEND_SRC_ALPHA`\n\t* (As/kA,As/kA,As/kA,As/kA)\n\t* \n\t* \n\t* `render.BLEND_ONE_MINUS_SRC_ALPHA`\n\t* (1,1,1,1) - (As/kA,As/kA,As/kA,As/kA)\n\t* \n\t* \n\t* `render.BLEND_DST_ALPHA`\n\t* (Ad/kA,Ad/kA,Ad/kA,Ad/kA)\n\t* \n\t* \n\t* `render.BLEND_ONE_MINUS_DST_ALPHA`\n\t* (1,1,1,1) - (Ad/kA,Ad/kA,Ad/kA,Ad/kA)\n\t* \n\t* \n\t* `render.BLEND_CONSTANT_COLOR`\n\t* (Rc,Gc,Bc,Ac)\n\t* \n\t* \n\t* `render.BLEND_ONE_MINUS_CONSTANT_COLOR`\n\t* (1,1,1,1) - (Rc,Gc,Bc,Ac)\n\t* \n\t* \n\t* `render.BLEND_CONSTANT_ALPHA`\n\t* (Ac,Ac,Ac,Ac)\n\t* \n\t* \n\t* `render.BLEND_ONE_MINUS_CONSTANT_ALPHA`\n\t* (1,1,1,1) - (Ac,Ac,Ac,Ac)\n\t* \n\t* \n\t* `render.BLEND_SRC_ALPHA_SATURATE`\n\t* (i,i,i,1) where i = min(As, kA - Ad) /kA\n\t* \n\t* \n\t* \n\t* The blended RGBA values of a pixel comes from the following equations:\n\t* \n\t* - Rd = min(kR, Rs * sR + Rd * dR)\n\t* - Gd = min(kG, Gs * sG + Gd * dG)\n\t* - Bd = min(kB, Bs * sB + Bd * dB)\n\t* - Ad = min(kA, As * sA + Ad * dA)\n\t* \n\t* Blend function `(render.BLEND_SRC_ALPHA, render.BLEND_ONE_MINUS_SRC_ALPHA)` is useful for\n\t* drawing with transparency when the drawn objects are sorted from farthest to nearest.\n\t* It is also useful for drawing antialiased points and lines in arbitrary order.\n\t* @param source_factor  source factor\n\t* @param destination_factor  destination factor\n\t*/\n\texport function set_blend_func(source_factor: any, destination_factor: any): void\n\n\t/**\n\t* Specifies whether the individual color components in the frame buffer is enabled for writing (`true`) or disabled (`false`). For example, if `blue` is `false`, nothing is written to the blue component of any pixel in any of the color buffers, regardless of the drawing operation attempted. Note that writing are either enabled or disabled for entire color components, not the individual bits of a component.\n\t* The component masks are all initially `true`.\n\t* @param red  red mask\n\t* @param green  green mask\n\t* @param blue  blue mask\n\t* @param alpha  alpha mask\n\t*/\n\texport function set_color_mask(red: boolean, green: boolean, blue: boolean, alpha: boolean): void\n\n\t/**\n\t* Specifies whether front- or back-facing polygons can be culled\n\t* when polygon culling is enabled. Polygon culling is initially disabled.\n\t* If mode is `render.FACE_FRONT_AND_BACK`, no polygons are drawn, but other\n\t* primitives such as points and lines are drawn. The initial value for\n\t* `face_type` is `render.FACE_BACK`.\n\t* @param face_type  face type\n\n- `render.FACE_FRONT`\n- `render.FACE_BACK`\n- `render.FACE_FRONT_AND_BACK`\n\n\t*/\n\texport function set_cull_face(face_type: any): void\n\n\t/**\n\t* Specifies the function that should be used to compare each incoming pixel\n\t* depth value with the value present in the depth buffer.\n\t* The comparison is performed only if depth testing is enabled and specifies\n\t* the conditions under which a pixel will be drawn.\n\t* Function constants:\n\t* \n\t* - `render.COMPARE_FUNC_NEVER` (never passes)\n\t* - `render.COMPARE_FUNC_LESS` (passes if the incoming depth value is less than the stored value)\n\t* - `render.COMPARE_FUNC_LEQUAL` (passes if the incoming depth value is less than or equal to the stored value)\n\t* - `render.COMPARE_FUNC_GREATER` (passes if the incoming depth value is greater than the stored value)\n\t* - `render.COMPARE_FUNC_GEQUAL` (passes if the incoming depth value is greater than or equal to the stored value)\n\t* - `render.COMPARE_FUNC_EQUAL` (passes if the incoming depth value is equal to the stored value)\n\t* - `render.COMPARE_FUNC_NOTEQUAL` (passes if the incoming depth value is not equal to the stored value)\n\t* - `render.COMPARE_FUNC_ALWAYS` (always passes)\n\t* \n\t* The depth function is initially set to `render.COMPARE_FUNC_LESS`.\n\t* @param func  depth test function, see the description for available values\n\t*/\n\texport function set_depth_func(func: any): void\n\n\t/**\n\t* Specifies whether the depth buffer is enabled for writing. The supplied mask governs\n\t* if depth buffer writing is enabled (`true`) or disabled (`false`).\n\t* The mask is initially `true`.\n\t* @param depth  depth mask\n\t*/\n\texport function set_depth_mask(depth: boolean): void\n\n\t/**\n\t* Sets the scale and units used to calculate depth values.\n\t* If `render.STATE_POLYGON_OFFSET_FILL` is enabled, each fragment\'s depth value\n\t* is offset from its interpolated value (depending on the depth value of the\n\t* appropriate vertices). Polygon offset can be used when drawing decals, rendering\n\t* hidden-line images etc.\n\t* `factor` specifies a scale factor that is used to create a variable depth\n\t* offset for each polygon. The initial value is `0`.\n\t* `units` is multiplied by an implementation-specific value to create a\n\t* constant depth offset. The initial value is `0`.\n\t* The value of the offset is computed as `factor` &times; `DZ` + `r` &times; `units`\n\t* `DZ` is a measurement of the depth slope of the polygon which is the change in z (depth)\n\t* values divided by the change in either x or y coordinates, as you traverse a polygon.\n\t* The depth values are in window coordinates, clamped to the range [0, 1].\n\t* `r` is the smallest value that is guaranteed to produce a resolvable difference.\n\t* It\'s value is an implementation-specific constant.\n\t* The offset is added before the depth test is performed and before the\n\t* value is written into the depth buffer.\n\t* @param factor  polygon offset factor\n\t* @param units  polygon offset units\n\t*/\n\texport function set_polygon_offset(factor: number, units: number): void\n\n\t/**\n\t* Sets the projection matrix to use when rendering.\n\t* @param matrix  projection matrix\n\t*/\n\texport function set_projection(matrix: vmath.matrix4): void\n\n\t/**\n\t* Sets a render target. Subsequent draw operations will be to the\n\t* render target until it is replaced by a subsequent call to set_render_target.\n\t* @param render_target  render target to set. render.RENDER_TARGET_DEFAULT to set the default render target\n\t* @param options  optional table with behaviour parameters\n\n`transient`\nTransient frame buffer types are only valid while the render target is active, i.e becomes undefined when a new target is set by a subsequent call to set_render_target.\n Default is all non-transient. Be aware that some hardware uses a combined depth stencil buffer and when this is the case both are considered non-transient if exclusively selected!\n A buffer type defined that doesn\'t exist in the render target is silently ignored.\n\n\n- `render.BUFFER_COLOR_BIT`\n- `render.BUFFER_DEPTH_BIT`\n- `render.BUFFER_STENCIL_BIT`\n\n\t*/\n\texport function set_render_target(render_target: any, options?: any): void\n\n\t/**\n\t* sets the render target size\n\t* @param render_target  render target to set size for\n\t* @param width  new render target width\n\t* @param height  new render target height\n\t*/\n\texport function set_render_target_size(render_target: any, width: number, height: number): void\n\n\t/**\n\t* Stenciling is similar to depth-buffering as it enables and disables drawing on a\n\t* per-pixel basis. First, GL drawing primitives are drawn into the stencil planes.\n\t* Second, geometry and images are rendered but using the stencil planes to mask out\n\t* where to draw.\n\t* The stencil test discards a pixel based on the outcome of a comparison between the\n\t* reference value `ref` and the corresponding value in the stencil buffer.\n\t* `func` specifies the comparison function. See the table below for values.\n\t* The initial value is `render.COMPARE_FUNC_ALWAYS`.\n\t* `ref` specifies the reference value for the stencil test. The value is clamped to\n\t* the range [0, 2n-1], where n is the number of bitplanes in the stencil buffer.\n\t* The initial value is `0`.\n\t* `mask` is ANDed with both the reference value and the stored stencil value when the test\n\t* is done. The initial value is all `1`\'s.\n\t* Function constant:\n\t* \n\t* - `render.COMPARE_FUNC_NEVER` (never passes)\n\t* - `render.COMPARE_FUNC_LESS` (passes if (ref &amp; mask) &lt; (stencil &amp; mask))\n\t* - `render.COMPARE_FUNC_LEQUAL` (passes if (ref &amp; mask) &lt;= (stencil &amp; mask))\n\t* - `render.COMPARE_FUNC_GREATER` (passes if (ref &amp; mask) &gt; (stencil &amp; mask))\n\t* - `render.COMPARE_FUNC_GEQUAL` (passes if (ref &amp; mask) &gt;= (stencil &amp; mask))\n\t* - `render.COMPARE_FUNC_EQUAL` (passes if (ref &amp; mask) = (stencil &amp; mask))\n\t* - `render.COMPARE_FUNC_NOTEQUAL` (passes if (ref &amp; mask) != (stencil &amp; mask))\n\t* - `render.COMPARE_FUNC_ALWAYS` (always passes)\n\t* \n\t* @param func  stencil test function, see the description for available values\n\t* @param ref  reference value for the stencil test\n\t* @param mask  mask that is ANDed with both the reference value and the stored stencil value when the test is done\n\t*/\n\texport function set_stencil_func(func: any, ref: number, mask: number): void\n\n\t/**\n\t* The stencil mask controls the writing of individual bits in the stencil buffer.\n\t* The least significant `n` bits of the parameter `mask`, where `n` is the number of\n\t* bits in the stencil buffer, specify the mask.\n\t* Where a `1` bit appears in the mask, the corresponding\n\t* bit in the stencil buffer can be written. Where a `0` bit appears in the mask,\n\t* the corresponding bit in the stencil buffer is never written.\n\t* The mask is initially all `1`\'s.\n\t* @param mask  stencil mask\n\t*/\n\texport function set_stencil_mask(mask: number): void\n\n\t/**\n\t* The stencil test discards a pixel based on the outcome of a comparison between the\n\t* reference value `ref` and the corresponding value in the stencil buffer.\n\t* To control the test, call render.set_stencil_func.\n\t* This function takes three arguments that control what happens to the stored stencil\n\t* value while stenciling is enabled. If the stencil test fails, no change is made to the\n\t* pixel\'s color or depth buffers, and `sfail` specifies what happens to the stencil buffer\n\t* contents.\n\t* Operator constants:\n\t* \n\t* - `render.STENCIL_OP_KEEP` (keeps the current value)\n\t* - `render.STENCIL_OP_ZERO` (sets the stencil buffer value to 0)\n\t* - `render.STENCIL_OP_REPLACE` (sets the stencil buffer value to `ref`, as specified by render.set_stencil_func)\n\t* - `render.STENCIL_OP_INCR` (increments the stencil buffer value and clamp to the maximum representable unsigned value)\n\t* - `render.STENCIL_OP_INCR_WRAP` (increments the stencil buffer value and wrap to zero when incrementing the maximum representable unsigned value)\n\t* - `render.STENCIL_OP_DECR` (decrements the current stencil buffer value and clamp to 0)\n\t* - `render.STENCIL_OP_DECR_WRAP` (decrements the current stencil buffer value and wrap to the maximum representable unsigned value when decrementing zero)\n\t* - `render.STENCIL_OP_INVERT` (bitwise inverts the current stencil buffer value)\n\t* \n\t* `dppass` and `dpfail` specify the stencil buffer actions depending on whether subsequent\n\t* depth buffer tests succeed (dppass) or fail (dpfail).\n\t* The initial value for all operators is `render.STENCIL_OP_KEEP`.\n\t* @param sfail  action to take when the stencil test fails\n\t* @param dpfail  the stencil action when the stencil test passes\n\t* @param dppass  the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled\n\t*/\n\texport function set_stencil_op(sfail: any, dpfail: any, dppass: any): void\n\n\t/**\n\t* Sets the view matrix to use when rendering.\n\t* @param matrix  view matrix to set\n\t*/\n\texport function set_view(matrix: vmath.matrix4): void\n\n\t/**\n\t* Set the render viewport to the specified rectangle.\n\t* @param x  left corner\n\t* @param y  bottom corner\n\t* @param width  viewport width\n\t* @param height  viewport height\n\t*/\n\texport function set_viewport(x: number, y: number, width: number, height: number): void\n\n\t/**\n\t* Set the size of the game window. Only works on desktop platforms.\n\t*/\n\texport type resize = "resize"\n\n\t/**\n\t* Reports a change in window size. This is initiated on window resize on desktop or by orientation changes\n\t* on mobile devices.\n\t*/\n\texport type window_resized = "window_resized"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace resource {\n\n\t/**\n\t* LIVEUPDATE_BUNDLED_RESOURCE_MISMATCH\n\t*/\n\texport let LIVEUPDATE_BUNDLED_RESOURCE_MISMATCH: any\n\n\t/**\n\t* LIVEUPDATE_ENGINE_VERSION_MISMATCH\n\t*/\n\texport let LIVEUPDATE_ENGINE_VERSION_MISMATCH: any\n\n\t/**\n\t* LIVEUPDATE_FORMAT_ERROR\n\t*/\n\texport let LIVEUPDATE_FORMAT_ERROR: any\n\n\t/**\n\t* LIVEUPDATE_INVALID_RESOURCE\n\t*/\n\texport let LIVEUPDATE_INVALID_RESOURCE: any\n\n\t/**\n\t* LIVEUPDATE_OK\n\t*/\n\texport let LIVEUPDATE_OK: any\n\n\t/**\n\t* LIVEUPDATE_SCHEME_MISMATCH\n\t*/\n\texport let LIVEUPDATE_SCHEME_MISMATCH: any\n\n\t/**\n\t* LIVEUPDATE_SIGNATURE_MISMATCH\n\t*/\n\texport let LIVEUPDATE_SIGNATURE_MISMATCH: any\n\n\t/**\n\t* LIVEUPDATE_VERSION_MISMATCH\n\t*/\n\texport let LIVEUPDATE_VERSION_MISMATCH: any\n\n\t/**\n\t* luminance type texture format\n\t*/\n\texport let TEXTURE_FORMAT_LUMINANCE: any\n\n\t/**\n\t* RGB type texture format\n\t*/\n\texport let TEXTURE_FORMAT_RGB: any\n\n\t/**\n\t* RGBA type texture format\n\t*/\n\texport let TEXTURE_FORMAT_RGBA: any\n\n\t/**\n\t* 2D texture type\n\t*/\n\texport let TEXTURE_TYPE_2D: any\n\n\t/**\n\t* Constructor-like function with two purposes:\n\t* \n\t* - Load the specified resource as part of loading the script\n\t* - Return a hash to the run-time version of the resource\n\t* \n\t* ⚠ This function can only be called within go.property function calls.\n\t* @param path  optional resource path string to the resource\n\t* @return path  a path hash to the binary version of the resource\n\t*/\n\texport function atlas(path?: string): hash\n\n\t/**\n\t* Constructor-like function with two purposes:\n\t* \n\t* - Load the specified resource as part of loading the script\n\t* - Return a hash to the run-time version of the resource\n\t* \n\t* ⚠ This function can only be called within go.property function calls.\n\t* @param path  optional resource path string to the resource\n\t* @return path  a path hash to the binary version of the resource\n\t*/\n\texport function buffer(path?: string): hash\n\n\t/**\n\t* Constructor-like function with two purposes:\n\t* \n\t* - Load the specified resource as part of loading the script\n\t* - Return a hash to the run-time version of the resource\n\t* \n\t* ⚠ This function can only be called within go.property function calls.\n\t* @param path  optional resource path string to the resource\n\t* @return path  a path hash to the binary version of the resource\n\t*/\n\texport function font(path?: string): hash\n\n\t/**\n\t* gets the buffer from a resource\n\t* @param path  The path to the resource\n\t* @return buffer  The resource buffer\n\t*/\n\texport function get_buffer(path: hash | string): buffer\n\n\t/**\n\t* Return a reference to the Manifest that is currently loaded.\n\t* @return manifest_reference  reference to the Manifest that is currently loaded\n\t*/\n\texport function get_current_manifest(): number\n\n\t/**\n\t* Is any liveupdate data mounted and currently in use?\n\t* This can be used to determine if a new manifest or zip file should be downloaded.\n\t* @return bool  true if a liveupdate archive (any format) has been loaded\n\t*/\n\texport function is_using_liveupdate_data(): any\n\n\t/**\n\t* Loads the resource data for a specific resource.\n\t* @param path  The path to the resource\n\t* @return buffer  Returns the buffer stored on disc\n\t*/\n\texport function load(path: string): buffer\n\n\t/**\n\t* Constructor-like function with two purposes:\n\t* \n\t* - Load the specified resource as part of loading the script\n\t* - Return a hash to the run-time version of the resource\n\t* \n\t* ⚠ This function can only be called within go.property function calls.\n\t* @param path  optional resource path string to the resource\n\t* @return path  a path hash to the binary version of the resource\n\t*/\n\texport function material(path?: string): hash\n\n\t/**\n\t* Sets the resource data for a specific resource\n\t* @param path  The path to the resource\n\t* @param buffer  The buffer of precreated data, suitable for the intended resource type\n\t*/\n\texport function set(path: string | hash, buffer: buffer): void\n\n\t/**\n\t* sets the buffer of a resource\n\t* @param path  The path to the resource\n\t* @param buffer  The resource buffer\n\t*/\n\texport function set_buffer(path: hash | string, buffer: buffer): void\n\n\t/**\n\t* Update internal sound resource (wavc/oggc) with new data\n\t* @param path  The path to the resource\n\t* @param buffer  A lua string containing the binary sound data\n\t*/\n\texport function set_sound(path: hash | string, buffer: string): void\n\n\t/**\n\t* Sets the pixel data for a specific texture.\n\t* @param path  The path to the resource\n\t* @param table  A table containing info about the texture. Supported entries:\n\n`type`\nThe texture type. Supported values:\n\n\n- `resource.TEXTURE_TYPE_2D`\n\n\n`width`\nThe width of the texture (in pixels)\n`height`\nThe width of the texture (in pixels)\n`format`\nThe texture format. Supported values:\n\n\n- `resource.TEXTURE_FORMAT_LUMINANCE`\n- `resource.TEXTURE_FORMAT_RGB`\n- `resource.TEXTURE_FORMAT_RGBA`\n\n\t* @param buffer  The buffer of precreated pixel data\n⚠ Currently, only 1 mipmap is generated.\n\t*/\n\texport function set_texture(path: hash | string, table: any, buffer: buffer): void\n\n\t/**\n\t* Stores a zip file and uses it for live update content.\n\t* The path is renamed and stored in the (internal) live update location\n\t* @param path  the path to the original file on disc\n\t* @param callback  the callback function\nexecuted after the storage has completed\n\n`self`\nThe current object.\n`status`\nthe status of the store operation (See resource.store_manifest)\n\n\t*/\n\texport function store_archive(path: string, callback: any): void\n\n\t/**\n\t* Create a new manifest from a buffer. The created manifest is verified\n\t* by ensuring that the manifest was signed using the bundled public/private\n\t* key-pair during the bundle process and that the manifest supports the current\n\t* running engine version. Once the manifest is verified it is stored on device.\n\t* The next time the engine starts (or is rebooted) it will look for the stored\n\t* manifest before loading resources. Storing a new manifest allows the\n\t* developer to update the game, modify existing resources, or add new\n\t* resources to the game through LiveUpdate.\n\t* @param manifest_buffer  the binary data that represents the manifest\n\t* @param callback  the callback function\nexecuted once the engine has attempted to store the manifest.\n\n`self`\nThe current object.\n`status`\nthe status of the store operation:\n\n\n- `resource.LIVEUPATE_OK`\n- `resource.LIVEUPATE_INVALID_RESOURCE`\n- `resource.LIVEUPATE_VERSION_MISMATCH`\n- `resource.LIVEUPATE_ENGINE_VERSION_MISMATCH`\n- `resource.LIVEUPATE_SIGNATURE_MISMATCH`\n- `resource.LIVEUPDATE_BUNDLED_RESOURCE_MISMATCH`\n- `resource.LIVEUPDATE_FORMAT_ERROR`\n\n\t*/\n\texport function store_manifest(manifest_buffer: string, callback: any): void\n\n\t/**\n\t* add a resource to the data archive and runtime index. The resource will be verified\n\t* internally before being added to the data archive.\n\t* @param manifest_reference  The manifest to check against.\n\t* @param data  The resource data that should be stored.\n\t* @param hexdigest  The expected hash for the resource,\nretrieved through collectionproxy.missing_resources.\n\t* @param callback  The callback\nfunction that is executed once the engine has been attempted to store\nthe resource.\n\n`self`\nThe current object.\n`hexdigest`\nThe hexdigest of the resource.\n`status`\nWhether or not the resource was successfully stored.\n\n\t*/\n\texport function store_resource(manifest_reference: number, data: string, hexdigest: string, callback: any): void\n\n\t/**\n\t* Constructor-like function with two purposes:\n\t* \n\t* - Load the specified resource as part of loading the script\n\t* - Return a hash to the run-time version of the resource\n\t* \n\t* ⚠ This function can only be called within go.property function calls.\n\t* @param path  optional resource path string to the resource\n\t* @return path  a path hash to the binary version of the resource\n\t*/\n\texport function texture(path?: string): hash\n\n\t/**\n\t* Constructor-like function with two purposes:\n\t* \n\t* - Load the specified resource as part of loading the script\n\t* - Return a hash to the run-time version of the resource\n\t* \n\t* ⚠ This function can only be called within go.property function calls.\n\t* @param path  optional resource path string to the resource\n\t* @return path  a path hash to the binary version of the resource\n\t*/\n\texport function tile_source(path?: string): hash\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace sys {\n\n\t/**\n\t* Terminates the game application and reports the specified `code` to the OS.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type exit = "exit"\n\n\t/**\n\t* Reboots the game engine with a specified set of arguments.\n\t* Arguments will be translated into command line arguments. Sending the reboot\n\t* command is equivalent to starting the engine with the same arguments.\n\t* On startup the engine reads configuration from "game.project" in the\n\t* project root.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type reboot = "reboot"\n\n\t/**\n\t* Set game update-frequency (frame cap). This option is equivalent to `display.update_frequency` in\n\t* the "game.project" settings but set in run-time. If `Vsync` checked in "game.project", the rate will\n\t* be clamped to a swap interval that matches any detected main monitor refresh rate. If `Vsync` is\n\t* unchecked the engine will try to respect the rate in software using timers. There is no\n\t* guarantee that the frame cap will be achieved depending on platform specifics and hardware settings.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type set_update_frequency = "set_update_frequency"\n\n\t/**\n\t* Set the vsync swap interval. The interval with which to swap the front and back buffers\n\t* in sync with vertical blanks (v-blank), the hardware event where the screen image is updated\n\t* with data from the front buffer. A value of 1 swaps the buffers at every v-blank, a value of\n\t* 2 swaps the buffers every other v-blank and so on. A value of 0 disables waiting for v-blank\n\t* before swapping the buffers. Default value is 1.\n\t* When setting the swap interval to 0 and having `vsync` disabled in\n\t* "game.project", the engine will try to respect the set frame cap value from\n\t* "game.project" in software instead.\n\t* This setting may be overridden by driver settings.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type set_vsync = "set_vsync"\n\n\t/**\n\t* Starts video recording of the game frame-buffer to file. Current video format is the\n\t* open vp8 codec in the ivf container. It\'s possible to upload this format directly\n\t* to YouTube. The VLC video player has native support but with the known issue that\n\t* not the entire file is played back. It\'s probably an issue with VLC.\n\t* The Miro Video Converter has support for vp8/ivf.\n\t* 🐧 Video recording is only supported on desktop platforms.\n\t* 🐧 Audio is currently not supported\n\t* 🐧 Window width and height must be a multiple of 8 to be able to record video.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type start_record = "start_record"\n\n\t/**\n\t* Stops the currently active video recording.\n\t* 🐧 Video recording is only supported on desktop platforms.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type stop_record = "stop_record"\n\n\t/**\n\t* network connected through other, non cellular, connection\n\t*/\n\texport let NETWORK_CONNECTED: any\n\n\t/**\n\t* network connected through mobile cellular\n\t*/\n\texport let NETWORK_CONNECTED_CELLULAR: any\n\n\t/**\n\t* no network connection found\n\t*/\n\texport let NETWORK_DISCONNECTED: any\n\n\t/**\n\t* Terminates the game application and reports the specified `code` to the OS.\n\t* @param code  exit code to report to the OS, 0 means clean exit\n\t*/\n\texport function exit(code: number): void\n\n\t/**\n\t* Returns a table with application information for the requested app.\n\t* 📱 On iOS, the `app_string` is an url scheme for the app that is queried. Your\n\t* game needs to list the schemes that are queried in an `LSApplicationQueriesSchemes` array\n\t* in a custom "Info.plist".\n\t* 📱 On Android, the `app_string` is the package identifier for the app.\n\t* @param app_string  platform specific string with application package or query, see above for details.\n\t* @return app_info  table with application information in the following fields:\n\n`installed`\n`true` if the application is installed, `false` otherwise.\n\n\t*/\n\texport function get_application_info(app_string: string): any\n\n\t/**\n\t* The path from which the application is run.\n\t* @return path  path to application executable\n\t*/\n\texport function get_application_path(): string\n\n\t/**\n\t* Get config value from the game.project configuration file.\n\t* In addition to the project file, configuration values can also be passed\n\t* to the runtime as command line arguments with the `--config` argument.\n\t* @param key  key to get value for. The syntax is SECTION.KEY\n\t* @return value  config value as a string. nil if the config key doesn\'t exists\n\t*/\n\texport function get_config(key: string): string\n\n\t/**\n\t* Get config value from the game.project configuration file with default value\n\t* @param key  key to get value for. The syntax is SECTION.KEY\n\t* @param default_value  default value to return if the value does not exist\n\t* @return value  config value as a string. default_value if the config key does not exist\n\t*/\n\texport function get_config(key: string, default_value: string): string\n\n\t/**\n\t* 🤖 Returns the current network connectivity status\n\t* on mobile platforms.\n\t* On desktop, this function always return `sys.NETWORK_CONNECTED`.\n\t* @return status  network connectivity status:\n\n- `sys.NETWORK_DISCONNECTED` (no network connection is found)\n- `sys.NETWORK_CONNECTED_CELLULAR` (connected through mobile cellular)\n- `sys.NETWORK_CONNECTED` (otherwise, Wifi)\n\n\t*/\n\texport function get_connectivity(): any\n\n\t/**\n\t* Returns a table with engine information.\n\t* @return engine_info  table with engine information in the following fields:\n\n`version`\nThe current Defold engine version, i.e. "1.2.96"\n`version_sha1`\nThe SHA1 for the current engine build, i.e. "0060183cce2e29dbd09c85ece83cbb72068ee050"\n`is_debug`\nIf the engine is a debug or release version\n\n\t*/\n\texport function get_engine_info(): any\n\n\t/**\n\t* Returns an array of tables with information on network interfaces.\n\t* @return ifaddrs  an array of tables. Each table entry contain the following fields:\n\n`name`\nInterface name\n`address`\nmight be `nil` if not available.\n`mac`\nmight be nil if not available.\n`up`\n`true` if the interface is up (available to transmit and receive data), `false` otherwise.\n`running`\n`true` if the interface is running, `false` otherwise.\n\n\t*/\n\texport function get_ifaddrs(): any\n\n\t/**\n\t* The save-file path is operating system specific and is typically located under the user\'s home directory.\n\t* @param application_id  user defined id of the application, which helps define the location of the save-file\n\t* @param file_name  file-name to get path for\n\t* @return path  path to save-file\n\t*/\n\texport function get_save_file(application_id: string, file_name: string): string\n\n\t/**\n\t* Returns a table with system information.\n\t* @return sys_info  table with system information in the following fields:\n\n`device_model`\nOnly available on iOS and Android.\n`manufacturer`\nOnly available on iOS and Android.\n`system_name`\nThe system OS name: "Darwin", "Linux", "Windows", "HTML5", "Android" or "iPhone OS"\n`system_version`\nThe system OS version.\n`api_version`\nThe API version on the system.\n`language`\nTwo character ISO-639 format, i.e. "en".\n`device_language`\nTwo character ISO-639 format (i.e. "sr") and, if applicable, followed by a dash (-) and an ISO 15924 script code (i.e. "sr-Cyrl" or "sr-Latn"). Reflects the device preferred language.\n`territory`\nTwo character ISO-3166 format, i.e. "US".\n`gmt_offset`\nThe current offset from GMT (Greenwich Mean Time), in minutes.\n`device_ident`\n"android_id" on Android. On Android, you need to add `READ_PHONE_STATE` permission to be able to get this data. We don\'t use this permission in Defold.\n`user_agent`\nThe HTTP user agent, i.e. "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/602.4.8 (KHTML, like Gecko) Version/10.0.3 Safari/602.4.8"\n\n\t*/\n\texport function get_sys_info(): any\n\n\t/**\n\t* If the file exists, it must have been created by `sys.save` to be loaded.\n\t* @param filename  file to read from\n\t* @return loaded  lua table, which is empty if the file could not be found\n\t*/\n\texport function load(filename: string): any\n\n\t/**\n\t* Loads a custom resource. Specify the full filename of the resource that you want\n\t* to load. When loaded, the file data is returned as a string.\n\t* If loading fails, the function returns nil plus the error message.\n\t* In order for the engine to include custom resources in the build process, you need\n\t* to specify them in the "custom_resources" key in your "game.project" settings file.\n\t* You can specify single resource files or directories. If a directory is included\n\t* in the resource list, all files and directories in that directory is recursively\n\t* included:\n\t* For example "main/data/,assets/level_data.json".\n\t* @param filename  resource to load, full path\n\t* @return data  loaded data, or `nil` if the resource could not be loaded\n\t* @return error  the error message, or `nil` if no error occurred\n\t*/\n\texport function load_resource(filename: string): LuaMultiReturn<[string, string]>\n\n\t/**\n\t* Open URL in default application, typically a browser\n\t* @param url  url to open\n\t* @param attributes  table with attributes\n`target`\n: Optional. Specifies the target attribute or the name of the window. The following values are supported:\n- `_self` - URL replaces the current page. This is default.\n- `_blank` - URL is loaded into a new window, or tab.\n- `_parent` - URL is loaded into the parent frame.\n- `_top` - URL replaces any framesets that may be loaded.\n- `name` - The name of the window (Note: the name does not specify the title of the new window).\n\t* @return success  a boolean indicating if the url could be opened or not\n\t*/\n\texport function open_url(url: string, attributes?: any): boolean\n\n\t/**\n\t* Reboots the game engine with a specified set of arguments.\n\t* Arguments will be translated into command line arguments. Calling reboot\n\t* function is equivalent to starting the engine with the same arguments.\n\t* On startup the engine reads configuration from "game.project" in the\n\t* project root.\n\t* @param arg1  argument 1\n\t* @param arg2  argument 2\n\t* @param arg3  argument 3\n\t* @param arg4  argument 4\n\t* @param arg5  argument 5\n\t* @param arg6  argument 6\n\t*/\n\texport function reboot(arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string): void\n\n\t/**\n\t* The table can later be loaded by `sys.load`.\n\t* Use `sys.get_save_file` to obtain a valid location for the file.\n\t* Internally, this function uses a workspace buffer sized output file sized 512kb.\n\t* This size reflects the output file size which must not exceed this limit.\n\t* Additionally, the total number of rows that any one table may contain is limited to 65536\n\t* (i.e. a 16 bit range). When tables are used to represent arrays, the values of\n\t* keys are permitted to fall within a 32 bit range, supporting sparse arrays, however\n\t* the limit on the total number of rows remains in effect.\n\t* @param filename  file to write to\n\t* @param table  lua table to save\n\t* @return success  a boolean indicating if the table could be saved or not\n\t*/\n\texport function save(filename: string, table: any): boolean\n\n\t/**\n\t* Sets the host that is used to check for network connectivity against.\n\t* @param host  hostname to check against\n\t*/\n\texport function set_connectivity_host(host: string): void\n\n\t/**\n\t* Set the Lua error handler function.\n\t* The error handler is a function which is called whenever a lua runtime error occurs.\n\t* @param error_handler  the function to be called on error\n\n`source`\nThe runtime context of the error. Currently, this is always `"lua"`.\n`message`\nThe source file, line number and error message.\n`traceback`\nThe stack traceback.\n\n\t*/\n\texport function set_error_handler(error_handler: any): void\n\n\t/**\n\t* Set game update-frequency (frame cap). This option is equivalent to `display.update_frequency` in\n\t* the "game.project" settings but set in run-time. If `Vsync` checked in "game.project", the rate will\n\t* be clamped to a swap interval that matches any detected main monitor refresh rate. If `Vsync` is\n\t* unchecked the engine will try to respect the rate in software using timers. There is no\n\t* guarantee that the frame cap will be achieved depending on platform specifics and hardware settings.\n\t* @param frequency  target frequency. 60 for 60 fps\n\t*/\n\texport function set_update_frequency(frequency: number): void\n\n\t/**\n\t* Set the vsync swap interval. The interval with which to swap the front and back buffers\n\t* in sync with vertical blanks (v-blank), the hardware event where the screen image is updated\n\t* with data from the front buffer. A value of 1 swaps the buffers at every v-blank, a value of\n\t* 2 swaps the buffers every other v-blank and so on. A value of 0 disables waiting for v-blank\n\t* before swapping the buffers. Default value is 1.\n\t* When setting the swap interval to 0 and having `vsync` disabled in\n\t* "game.project", the engine will try to respect the set frame cap value from\n\t* "game.project" in software instead.\n\t* This setting may be overridden by driver settings.\n\t* @param swap_interval  target swap interval.\n\t*/\n\texport function set_vsync_swap_interval(swap_interval: number): void\n\n\t/**\n\t* Toggles the on-screen physics visual debugging mode which is very useful for\n\t* tracking down issues related to physics. This mode visualizes\n\t* all collision object shapes and normals at detected contact points. Toggling\n\t* this mode on is equal to setting `physics.debug` in the "game.project" settings,\n\t* but set in run-time.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type toggle_physics_debug = "toggle_physics_debug"\n\n\t/**\n\t* Toggles the on-screen profiler.\n\t* The profiler is a real-time tool that shows the numbers of milliseconds spent\n\t* in each scope per frame as well as counters. The profiler is very useful for\n\t* tracking down performance and resource problems.\n\t* In addition to the on-screen profiler, Defold includes a web-based profiler that\n\t* allows you to sample a series of data points and then analyze them in detail.\n\t* The web profiler is available at `http://&lt;device IP&gt;:8002` where  is\n\t* the IP address of the device you are running your game on.\n\t* This message can only be sent to the designated `@system` socket.\n\t*/\n\texport type toggle_profile = "toggle_profile"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace window {\n\n\t/**\n\t* dimming mode off\n\t*/\n\texport let DIMMING_OFF: any\n\n\t/**\n\t* dimming mode on\n\t*/\n\texport let DIMMING_ON: any\n\n\t/**\n\t* dimming mode unknown\n\t*/\n\texport let DIMMING_UNKNOWN: any\n\n\t/**\n\t* deiconified window event\n\t*/\n\texport let WINDOW_EVENT_DEICONIFIED: any\n\n\t/**\n\t* focus gained window event\n\t*/\n\texport let WINDOW_EVENT_FOCUS_GAINED: any\n\n\t/**\n\t* focus lost window event\n\t*/\n\texport let WINDOW_EVENT_FOCUS_LOST: any\n\n\t/**\n\t* iconify window event\n\t*/\n\texport let WINDOW_EVENT_ICONFIED: any\n\n\t/**\n\t* resized window event\n\t*/\n\texport let WINDOW_EVENT_RESIZED: any\n\n\t/**\n\t* 🤖 Returns the current dimming mode set on a mobile device.\n\t* The dimming mode specifies whether or not a mobile device should dim the screen after a period without user interaction.\n\t* On platforms that does not support dimming, `window.DIMMING_UNKNOWN` is always returned.\n\t* @return mode  The mode for screen dimming\n\n- `window.DIMMING_UNKNOWN`\n- `window.DIMMING_ON`\n- `window.DIMMING_OFF`\n\n\t*/\n\texport function get_dim_mode(): any\n\n\t/**\n\t* This returns the current window size (width and height).\n\t* @return width  The window width\n\t* @return height  The window height\n\t*/\n\texport function get_size(): LuaMultiReturn<[number, number]>\n\n\t/**\n\t* 🤖 Sets the dimming mode on a mobile device.\n\t* The dimming mode specifies whether or not a mobile device should dim the screen after a period without user interaction. The dimming mode will only affect the mobile device while the game is in focus on the device, but not when the game is running in the background.\n\t* This function has no effect on platforms that does not support dimming.\n\t* @param mode  The mode for screen dimming\n\n- `window.DIMMING_ON`\n- `window.DIMMING_OFF`\n\n\t*/\n\texport function set_dim_mode(mode: any): void\n\n\t/**\n\t* Sets a window event listener.\n\t* @param callback  A callback which receives info about window events. Pass an empty function or nil if you no longer wish to receive callbacks.\n\n`self`\nThe calling script\n`event`\nThe type of event. Can be one of these:\n\n\n- `window.WINDOW_EVENT_FOCUS_LOST`\n- `window.WINDOW_EVENT_FOCUS_GAINED`\n- `window.WINDOW_EVENT_RESIZED`\n- `window.WINDOW_EVENT_ICONIFIED`\n- `window.WINDOW_EVENT_DEICONIFIED`\n\n\n`data`\nThe callback value `data` is a table which currently holds these values\n\n\n`width`: The width of a resize event. nil otherwise.\n`height`: The height of a resize event. nil otherwise.\n\n\t*/\n\texport function set_listener(callback: any): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace buffer {\n\n\t/**\n\t* float32\n\t*/\n\texport let VALUE_TYPE_FLOAT32: any\n\n\t/**\n\t* int16\n\t*/\n\texport let VALUE_TYPE_INT16: any\n\n\t/**\n\t* int32\n\t*/\n\texport let VALUE_TYPE_INT32: any\n\n\t/**\n\t* int64\n\t*/\n\texport let VALUE_TYPE_INT64: any\n\n\t/**\n\t* int8\n\t*/\n\texport let VALUE_TYPE_INT8: any\n\n\t/**\n\t* uint16\n\t*/\n\texport let VALUE_TYPE_UINT16: any\n\n\t/**\n\t* uint32\n\t*/\n\texport let VALUE_TYPE_UINT32: any\n\n\t/**\n\t* uint64\n\t*/\n\texport let VALUE_TYPE_UINT64: any\n\n\t/**\n\t* uint8\n\t*/\n\texport let VALUE_TYPE_UINT8: any\n\n\t/**\n\t* Copy all data streams from one buffer to another, element wise.\n\t* ⚠ Each of the source streams must have a matching stream in the\n\t* destination buffer. The streams must match in both type and size.\n\t* The source and destination buffer can be the same.\n\t* @param dst  the destination buffer\n\t* @param dstoffset  the offset to start copying data to\n\t* @param src  the source data buffer\n\t* @param srcoffset  the offset to start copying data from\n\t* @param count  the number of elements to copy\n\t*/\n\texport function copy_buffer(dst: buffer, dstoffset: number, src: buffer, srcoffset: number, count: number): void\n\n\t/**\n\t* Copy a specified amount of data from one stream to another.\n\t* ⚠ The value type and size must match between source and destination streams.\n\t* The source and destination streams can be the same.\n\t* @param dst  the destination stream\n\t* @param dstoffset  the offset to start copying data to (measured in value type)\n\t* @param src  the source data stream\n\t* @param srcoffset  the offset to start copying data from (measured in value type)\n\t* @param count  the number of values to copy (measured in value type)\n\t*/\n\texport function copy_stream(dst: bufferstream, dstoffset: number, src: bufferstream, srcoffset: number, count: number): void\n\n\t/**\n\t* Create a new data buffer containing a specified set of streams. A data buffer\n\t* can contain one or more streams with typed data. This is useful for managing\n\t* compound data, for instance a vertex buffer could contain separate streams for\n\t* vertex position, color, normal etc.\n\t* @param element_count  The number of elements the buffer should hold\n\t* @param declaration  A table where each entry (table) describes a stream\n\n`name`: The name of the stream\n`type`: The data type of the stream\n`count`: The number of values each element should hold\n\n\t* @return buffer  the new buffer\n\t*/\n\texport function create(element_count: number, declaration: any): buffer\n\n\t/**\n\t* Get a copy of all the bytes from a specified stream as a Lua string.\n\t* @param buffer  the source buffer\n\t* @param stream_name  the name of the stream\n\t* @return data  the buffer data as a Lua string\n\t*/\n\texport function get_bytes(buffer: buffer, stream_name: hash): string\n\n\t/**\n\t* Get a specified stream from a buffer.\n\t* @param buffer  the buffer to get the stream from\n\t* @param stream_name  the stream name\n\t* @return stream  the data stream\n\t*/\n\texport function get_stream(buffer: buffer, stream_name: hash | string): bufferstream\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace html5 {\n\n\t/**\n\t* Executes the supplied string as JavaScript inside the browser.\n\t* A call to this function is blocking, the result is returned as-is, as a string.\n\t* (Internally this will execute the string using the `eval()` JavaScript function.)\n\t* @param code  Javascript code to run\n\t* @return result  result as string\n\t*/\n\texport function run(code: string): string\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace http {\n\n\t/**\n\t* Perform a HTTP/HTTPS request.\n\t* ⚠ If no timeout value is passed, the configuration value "network.http_timeout" is used. If that is not set, the timeout value is `0` (which blocks indefinitely).\n\t* @param url  target url\n\t* @param method  HTTP/HTTPS method, e.g. "GET", "PUT", "POST" etc.\n\t* @param callback  response callback function\n\n`self`\nThe script instance\n`id`\nInternal message identifier. Do not use!\n`response`\nThe response data. Contains the fields:\n\n\n`status`: the status of the response\n`response`: the response data (if not saved on disc)\n`headers`: all the returned headers\n`path`: the stored path (if saved to disc)\n`error`: if any unforeseen errors occurred (e.g. file I/O)\n\n\t* @param headers  optional table with custom headers\n\t* @param post_data  optional data to send\n\t* @param options  optional table with request parameters. Supported entries:\n\n`timeout`: timeout in seconds\n`path`: path on disc where to download the file. Only overwrites the path if status is 200\n`ignore_cache`: don\'t return cached data if we get a 304\n\n\t*/\n\texport function request(url: string, method: string, callback: any, headers?: any, post_data?: string, options?: any): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace image {\n\n\t/**\n\t* luminance image type\n\t*/\n\texport let TYPE_LUMINANCE: any\n\n\t/**\n\t* RGB image type\n\t*/\n\texport let TYPE_RGB: any\n\n\t/**\n\t* RGBA image type\n\t*/\n\texport let TYPE_RGBA: any\n\n\t/**\n\t* Load image (PNG or JPEG) from buffer.\n\t* @param buffer  image data buffer\n\t* @param premult  optional flag if alpha should be premultiplied. Defaults to `false`\n\t* @return image  object or `nil` if loading fails. The object is a table with the following fields:\n\n`width`: image width\n`height`: image height\n`type`: image type\n- `image.TYPE_RGB`\n- `image.TYPE_RGBA`\n- `image.TYPE_LUMINANCE`\n\n\n`buffer`: the raw image data\n\n\t*/\n\texport function load(buffer: string, premult?: boolean): any\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace json {\n\n\t/**\n\t* Decode a string of JSON data into a Lua table.\n\t* A Lua error is raised for syntax errors.\n\t* @param json  json data\n\t* @return data  decoded json\n\t*/\n\texport function decode(json: string): any\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace msg {\n\n\t/**\n\t* Post a message to a receiving URL. The most common case is to send messages\n\t* to a component. If the component part of the receiver is omitted, the message\n\t* is broadcast to all components in the game object.\n\t* The following receiver shorthands are available:\n\t* \n\t* - `"."` the current game object\n\t* - `"#"` the current component\n\t* \n\t* ⚠ There is a 2 kilobyte limit to the message parameter table size.\n\t* @param receiver  The receiver must be a string in URL-format, a URL object or a hashed string.\n\t* @param message_id  The id must be a string or a hashed string.\n\t* @param message  a lua table with message parameters to send.\n\t*/\n\texport function post(receiver: string | url | hash, message_id: string | hash, message?: any): void\n\n\t/**\n\t* This is equivalent to `msg.url(nil)` or `msg.url("#")`, which creates an url to the current\n\t* script component.\n\t* @return url  a new URL\n\t*/\n\texport function url(): url\n\n\t/**\n\t* The format of the string must be `[socket:][path][#fragment]`, which is similar to a HTTP URL.\n\t* When addressing instances:\n\t* \n\t* - `socket` is the name of a valid world (a collection)\n\t* - `path` is the id of the instance, which can either be relative the instance of the calling script or global\n\t* - `fragment` would be the id of the desired component\n\t* \n\t* In addition, the following shorthands are available:\n\t* \n\t* - `"."` the current game object\n\t* - `"#"` the current component\n\t* \n\t* @param urlstring  string to create the url from\n\t* @return url  a new URL\n\t*/\n\texport function url(urlstring: string): url\n\n\t/**\n\t* creates a new URL from separate arguments\n\t* @param socket  socket of the URL\n\t* @param path  path of the URL\n\t* @param fragment  fragment of the URL\n\t* @return url  a new URL\n\t*/\n\texport function url(socket?: string | hash, path?: string | hash, fragment?: string | hash): url\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace timer {\n\n\t/**\n\t* Indicates an invalid timer handle\n\t*/\n\texport let INVALID_TIMER_HANDLE: any\n\n\t/**\n\t* You may cancel a timer from inside a timer callback.\n\t* Cancelling a timer that is already executed or cancelled is safe.\n\t* @param handle  the timer handle returned by timer.delay()\n\t* @return true  if the timer was active, false if the timer is already cancelled / complete\n\t*/\n\texport function cancel(handle: hash): boolean\n\n\t/**\n\t* Adds a timer and returns a unique handle\n\t* You may create more timers from inside a timer callback.\n\t* Using a delay of 0 will result in a timer that triggers at the next frame just before\n\t* script update functions.\n\t* If you want a timer that triggers on each frame, set delay to 0.0f and repeat to true.\n\t* Timers created within a script will automatically die when the script is deleted.\n\t* @param delay  time interval in seconds\n\t* @param repeat  true = repeat timer until cancel, false = one-shot timer\n\t* @param callback  timer callback function\n\n`self`\nThe current object\n`handle`\nThe handle of the timer\n`time_elapsed`\nThe elapsed time - on first trigger it is time since timer.delay call, otherwise time since last trigger\n\n\t* @return   handle identifier for the create timer, returns timer.INVALID_TIMER_HANDLE if the timer can not be created\n\t*/\n\texport function delay(delay: number, repeat: boolean, callback: any): hash\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace vmath {\n\n\t/**\n\t* Calculates the conjugate of a quaternion. The result is a\n\t* quaternion with the same magnitudes but with the sign of\n\t* the imaginary (vector) parts changed:\n\t* `q* = [w, -v]`\n\t* @param q1  quaternion of which to calculate the conjugate\n\t* @return q  the conjugate\n\t*/\n\texport function conj(q1: vmath.quaternion): vmath.quaternion\n\n\t/**\n\t* Given two linearly independent vectors P and Q, the cross product,\n\t* P &#x00D7; Q, is a vector that is perpendicular to both P and Q and\n\t* therefore normal to the plane containing them.\n\t* If the two vectors have the same direction (or have the exact\n\t* opposite direction from one another, i.e. are not linearly independent)\n\t* or if either one has zero length, then their cross product is zero.\n\t* @param v1  first vector\n\t* @param v2  second vector\n\t* @return v  a new vector representing the cross product\n\t*/\n\texport function cross(v1: vmath.vector3, v2: vmath.vector3): vmath.vector3\n\n\t/**\n\t* The returned value is a scalar defined as:\n\t* `P &#x22C5; Q = |P| |Q| cos &#x03B8;`\n\t* where &#x03B8; is the angle between the vectors P and Q.\n\t* \n\t* - If the dot product is positive then the angle between the vectors is below 90 degrees.\n\t* - If the dot product is zero the vectors are perpendicular (at right-angles to each other).\n\t* - If the dot product is negative then the angle between the vectors is more than 90 degrees.\n\t* \n\t* @param v1  first vector\n\t* @param v2  second vector\n\t* @return n  dot product\n\t*/\n\texport function dot(v1: vmath.vector3 | vmath.vector4, v2: vmath.vector3 | vmath.vector4): number\n\n\t/**\n\t* The resulting matrix is the inverse of the supplied matrix.\n\t* ⚠ For ortho-normal matrices, e.g. regular object transformation,\n\t* use `vmath.ortho_inv()` instead.\n\t* The specialized inverse for ortho-normalized matrices is much faster\n\t* than the general inverse.\n\t* @param m1  matrix to invert\n\t* @return m  inverse of the supplied matrix\n\t*/\n\texport function inv(m1: vmath.matrix4): vmath.matrix4\n\n\t/**\n\t* Returns the length of the supplied vector or quaternion.\n\t* If you are comparing the lengths of vectors or quaternions, you should compare\n\t* the length squared instead as it is slightly more efficient to calculate\n\t* (it eliminates a square root calculation).\n\t* @param v  value of which to calculate the length\n\t* @return n  length\n\t*/\n\texport function length(v: vmath.vector3 | vmath.vector4 | vmath.quaternion): number\n\n\t/**\n\t* Returns the squared length of the supplied vector or quaternion.\n\t* @param v  value of which to calculate the squared length\n\t* @return n  squared length\n\t*/\n\texport function length_sqr(v: vmath.vector3 | vmath.vector4 | vmath.quaternion): number\n\n\t/**\n\t* Linearly interpolate between two vectors. The function\n\t* treats the vectors as positions and interpolates between\n\t* the positions in a straight line. Lerp is useful to describe\n\t* transitions from one place to another over time.\n\t* ⚠ The function does not clamp t between 0 and 1.\n\t* @param t  interpolation parameter, 0-1\n\t* @param v1  vector to lerp from\n\t* @param v2  vector to lerp to\n\t* @return v  the lerped vector\n\t*/\n\texport function lerp(t: number, v1: vmath.vector3, v2: vmath.vector3): vmath.vector3\n\texport function lerp(t: number, v1: vmath.vector4, v2: vmath.vector4): vmath.vector4\n\n\t/**\n\t* Linearly interpolate between two quaternions. Linear\n\t* interpolation of rotations are only useful for small\n\t* rotations. For interpolations of arbitrary rotations,\n\t* vmath.slerp yields much better results.\n\t* ⚠ The function does not clamp t between 0 and 1.\n\t* @param t  interpolation parameter, 0-1\n\t* @param q1  quaternion to lerp from\n\t* @param q2  quaternion to lerp to\n\t* @return q  the lerped quaternion\n\t*/\n\texport function lerp(t: number, q1: vmath.quaternion, q2: vmath.quaternion): vmath.quaternion\n\n\t/**\n\t* Linearly interpolate between two values. Lerp is useful\n\t* to describe transitions from one value to another over time.\n\t* ⚠ The function does not clamp t between 0 and 1.\n\t* @param t  interpolation parameter, 0-1\n\t* @param n1  number to lerp from\n\t* @param n2  number to lerp to\n\t* @return n  the lerped number\n\t*/\n\texport function lerp(t: number, n1: number, n2: number): number\n\n\t/**\n\t* The resulting identity matrix describes a transform with\n\t* no translation or rotation.\n\t* @return m  identity matrix\n\t*/\n\texport function matrix4(): vmath.matrix4\n\n\t/**\n\t* Creates a new matrix with all components set to the\n\t* corresponding values from the supplied matrix. I.e.\n\t* the function creates a copy of the given matrix.\n\t* @param m1  existing matrix\n\t* @return m  matrix which is a copy of the specified matrix\n\t*/\n\texport function matrix4(m1: vmath.matrix4): vmath.matrix4\n\n\t/**\n\t* The resulting matrix describes a rotation around the axis by the specified angle.\n\t* @param v  axis\n\t* @param angle  angle in radians\n\t* @return m  matrix represented by axis and angle\n\t*/\n\texport function matrix4_axis_angle(v: vmath.vector3, angle: number): vmath.matrix4\n\n\t/**\n\t* The resulting matrix describes the same rotation as the quaternion, but does not have any translation (also like the quaternion).\n\t* @param q  quaternion to create matrix from\n\t* @return m  matrix represented by quaternion\n\t*/\n\texport function matrix4_from_quat(q: vmath.quaternion): vmath.matrix4\n\n\t/**\n\t* Constructs a frustum matrix from the given values. The left, right,\n\t* top and bottom coordinates of the view cone are expressed as distances\n\t* from the center of the near clipping plane. The near and far coordinates\n\t* are expressed as distances from the tip of the view frustum cone.\n\t* @param left  coordinate for left clipping plane\n\t* @param right  coordinate for right clipping plane\n\t* @param bottom  coordinate for bottom clipping plane\n\t* @param top  coordinate for top clipping plane\n\t* @param near  coordinate for near clipping plane\n\t* @param far  coordinate for far clipping plane\n\t* @return m  matrix representing the frustum\n\t*/\n\texport function matrix4_frustum(left: number, right: number, bottom: number, top: number, near: number, far: number): vmath.matrix4\n\n\t/**\n\t* The resulting matrix is created from the supplied look-at parameters.\n\t* This is useful for constructing a view matrix for a camera or\n\t* rendering in general.\n\t* @param eye  eye position\n\t* @param look_at  look-at position\n\t* @param up  up vector\n\t* @return m  look-at matrix\n\t*/\n\texport function matrix4_look_at(eye: vmath.vector3, look_at: vmath.vector3, up: vmath.vector3): vmath.matrix4\n\n\t/**\n\t* Creates an orthographic projection matrix.\n\t* This is useful to construct a projection matrix for a camera or rendering in general.\n\t* @param left  coordinate for left clipping plane\n\t* @param right  coordinate for right clipping plane\n\t* @param bottom  coordinate for bottom clipping plane\n\t* @param top  coordinate for top clipping plane\n\t* @param near  coordinate for near clipping plane\n\t* @param far  coordinate for far clipping plane\n\t* @return m  orthographic projection matrix\n\t*/\n\texport function matrix4_orthographic(left: number, right: number, bottom: number, top: number, near: number, far: number): vmath.matrix4\n\n\t/**\n\t* Creates a perspective projection matrix.\n\t* This is useful to construct a projection matrix for a camera or rendering in general.\n\t* @param fov  angle of the full vertical field of view in radians\n\t* @param aspect  aspect ratio\n\t* @param near  coordinate for near clipping plane\n\t* @param far  coordinate for far clipping plane\n\t* @return m  perspective projection matrix\n\t*/\n\texport function matrix4_perspective(fov: number, aspect: number, near: number, far: number): vmath.matrix4\n\n\t/**\n\t* The resulting matrix describes a rotation around the x-axis\n\t* by the specified angle.\n\t* @param angle  angle in radians around x-axis\n\t* @return m  matrix from rotation around x-axis\n\t*/\n\texport function matrix4_rotation_x(angle: number): vmath.matrix4\n\n\t/**\n\t* The resulting matrix describes a rotation around the y-axis\n\t* by the specified angle.\n\t* @param angle  angle in radians around y-axis\n\t* @return m  matrix from rotation around y-axis\n\t*/\n\texport function matrix4_rotation_y(angle: number): vmath.matrix4\n\n\t/**\n\t* The resulting matrix describes a rotation around the z-axis\n\t* by the specified angle.\n\t* @param angle  angle in radians around z-axis\n\t* @return m  matrix from rotation around z-axis\n\t*/\n\texport function matrix4_rotation_z(angle: number): vmath.matrix4\n\n\t/**\n\t* The resulting matrix describes a translation of a point\n\t* in euclidean space.\n\t* @param position  position vector to create matrix from\n\t* @return m  matrix from the supplied position vector\n\t*/\n\texport function matrix4_translation(position: vmath.vector3 | vmath.vector4): vmath.matrix4\n\n\t/**\n\t* Performs an element wise multiplication between two vectors of the same type\n\t* The returned value is a vector defined as (e.g. for a vector3):\n\t* `v = vmath.mul_per_elem(a, b) = vmath.vector3(a.x * b.x, a.y * b.y, a.z * b.z)`\n\t* @param v1  first vector\n\t* @param v2  second vector\n\t* @return v  multiplied vector\n\t*/\n\texport function mul_per_elem(v1: vmath.vector3, v2: vmath.vector3): vmath.vector3\n\texport function mul_per_elem(v1: vmath.vector4, v2: vmath.vector4): vmath.vector4\n\n\t/**\n\t* Normalizes a vector, i.e. returns a new vector with the same\n\t* direction as the input vector, but with length 1.\n\t* ⚠ The length of the vector must be above 0, otherwise a\n\t* division-by-zero will occur.\n\t* @param v1  vector to normalize\n\t* @return v  new normalized vector\n\t*/\n\texport function normalize(v1: vmath.vector3): vmath.vector3\n\texport function normalize(v1: vmath.vector4): vmath.vector4\n\texport function normalize(v1: vmath.quaternion): vmath.quaternion\n\n\t/**\n\t* The resulting matrix is the inverse of the supplied matrix.\n\t* The supplied matrix has to be an ortho-normal matrix, e.g.\n\t* describe a regular object transformation.\n\t* ⚠ For matrices that are not ortho-normal\n\t* use the general inverse `vmath.inv()` instead.\n\t* @param m1  ortho-normalized matrix to invert\n\t* @return m  inverse of the supplied matrix\n\t*/\n\texport function ortho_inv(m1: vmath.matrix4): vmath.matrix4\n\n\t/**\n\t* Calculates the extent the projection of the first vector onto the second.\n\t* The returned value is a scalar p defined as:\n\t* `p = |P| cos &#x03B8; / |Q|`\n\t* where &#x03B8; is the angle between the vectors P and Q.\n\t* @param v1  vector to be projected on the second\n\t* @param v2  vector onto which the first will be projected, must not have zero length\n\t* @return n  the projected extent of the first vector onto the second\n\t*/\n\texport function project(v1: vmath.vector3, v2: vmath.vector3): number\n\n\t/**\n\t* Creates a new identity quaternion. The identity\n\t* quaternion is equal to:\n\t* `vmath.quat(0, 0, 0, 1)`\n\t* @return q  new identity quaternion\n\t*/\n\texport function quat(): vmath.quaternion\n\n\t/**\n\t* Creates a new quaternion with all components set to the\n\t* corresponding values from the supplied quaternion. I.e.\n\t* This function creates a copy of the given quaternion.\n\t* @param q1  existing quaternion\n\t* @return q  new quaternion\n\t*/\n\texport function quat(q1: vmath.quaternion): vmath.quaternion\n\n\t/**\n\t* Creates a new quaternion with the components set\n\t* according to the supplied parameter values.\n\t* @param x  x coordinate\n\t* @param y  y coordinate\n\t* @param z  z coordinate\n\t* @param w  w coordinate\n\t* @return q  new quaternion\n\t*/\n\texport function quat(x: number, y: number, z: number, w: number): vmath.quaternion\n\n\t/**\n\t* The resulting quaternion describes a rotation of `angle`\n\t* radians around the axis described by the unit vector `v`.\n\t* @param v  axis\n\t* @param angle  angle\n\t* @return q  quaternion representing the axis-angle rotation\n\t*/\n\texport function quat_axis_angle(v: vmath.vector3, angle: number): vmath.quaternion\n\n\t/**\n\t* The resulting quaternion describes the rotation from the\n\t* identity quaternion (no rotation) to the coordinate system\n\t* as described by the given x, y and z base unit vectors.\n\t* @param x  x base vector\n\t* @param y  y base vector\n\t* @param z  z base vector\n\t* @return q  quaternion representing the rotation of the specified base vectors\n\t*/\n\texport function quat_basis(x: vmath.vector3, y: vmath.vector3, z: vmath.vector3): vmath.quaternion\n\n\t/**\n\t* The resulting quaternion describes the rotation that,\n\t* if applied to the first vector, would rotate the first\n\t* vector to the second. The two vectors must be unit\n\t* vectors (of length 1).\n\t* ⚠ The result is undefined if the two vectors point in opposite directions\n\t* @param v1  first unit vector, before rotation\n\t* @param v2  second unit vector, after rotation\n\t* @return q  quaternion representing the rotation from first to second vector\n\t*/\n\texport function quat_from_to(v1: vmath.vector3, v2: vmath.vector3): vmath.quaternion\n\n\t/**\n\t* The resulting quaternion describes a rotation of `angle`\n\t* radians around the x-axis.\n\t* @param angle  angle in radians around x-axis\n\t* @return q  quaternion representing the rotation around the x-axis\n\t*/\n\texport function quat_rotation_x(angle: number): vmath.quaternion\n\n\t/**\n\t* The resulting quaternion describes a rotation of `angle`\n\t* radians around the y-axis.\n\t* @param angle  angle in radians around y-axis\n\t* @return q  quaternion representing the rotation around the y-axis\n\t*/\n\texport function quat_rotation_y(angle: number): vmath.quaternion\n\n\t/**\n\t* The resulting quaternion describes a rotation of `angle`\n\t* radians around the z-axis.\n\t* @param angle  angle in radians around z-axis\n\t* @return q  quaternion representing the rotation around the z-axis\n\t*/\n\texport function quat_rotation_z(angle: number): vmath.quaternion\n\n\t/**\n\t* Returns a new vector from the supplied vector that is\n\t* rotated by the rotation described by the supplied\n\t* quaternion.\n\t* @param q  quaternion\n\t* @param v1  vector to rotate\n\t* @return v  the rotated vector\n\t*/\n\texport function rotate(q: vmath.quaternion, v1: vmath.vector3): vmath.vector3\n\n\t/**\n\t* Spherically interpolates between two vectors. The difference to\n\t* lerp is that slerp treats the vectors as directions instead of\n\t* positions in space.\n\t* The direction of the returned vector is interpolated by the angle\n\t* and the magnitude is interpolated between the magnitudes of the\n\t* from and to vectors.\n\t* ⚠ Slerp is computationally more expensive than lerp.\n\t* The function does not clamp t between 0 and 1.\n\t* @param t  interpolation parameter, 0-1\n\t* @param v1  vector to slerp from\n\t* @param v2  vector to slerp to\n\t* @return v  the slerped vector\n\t*/\n\texport function slerp(t: number, v1: vmath.vector3, v2: vmath.vector3): vmath.vector3\n\texport function slerp(t: number, v1: vmath.vector4, v2: vmath.vector4): vmath.vector4\n\n\t/**\n\t* Slerp travels the torque-minimal path maintaining constant\n\t* velocity, which means it travels along the straightest path along\n\t* the rounded surface of a sphere. Slerp is useful for interpolation\n\t* of rotations.\n\t* Slerp travels the torque-minimal path, which means it travels\n\t* along the straightest path the rounded surface of a sphere.\n\t* ⚠ The function does not clamp t between 0 and 1.\n\t* @param t  interpolation parameter, 0-1\n\t* @param q1  quaternion to slerp from\n\t* @param q2  quaternion to slerp to\n\t* @return q  the slerped quaternion\n\t*/\n\texport function slerp(t: number, q1: vmath.quaternion, q2: vmath.quaternion): vmath.quaternion\n\n\t/**\n\t* Creates a vector of arbitrary size. The vector is initialized\n\t* with numeric values from a table.\n\t* ⚠ The table values are converted to floating point\n\t* values. If a value cannot be converted, a 0 is stored in that\n\t* value position in the vector.\n\t* @param t  table of numbers\n\t* @return v  new vector\n\t*/\n\texport function vector(t: any): any\n\n\t/**\n\t* Creates a new zero vector with all components set to 0.\n\t* @return v  new zero vector\n\t*/\n\texport function vector3(): vmath.vector3\n\n\t/**\n\t* Creates a new vector with all components set to the\n\t* supplied scalar value.\n\t* @param n  scalar value to splat\n\t* @return v  new vector\n\t*/\n\texport function vector3(n: number): vmath.vector3\n\n\t/**\n\t* Creates a new vector with all components set to the\n\t* corresponding values from the supplied vector. I.e.\n\t* This function creates a copy of the given vector.\n\t* @param v1  existing vector\n\t* @return v  new vector\n\t*/\n\texport function vector3(v1: vmath.vector3): vmath.vector3\n\n\t/**\n\t* Creates a new vector with the components set to the\n\t* supplied values.\n\t* @param x  x coordinate\n\t* @param y  y coordinate\n\t* @param z  z coordinate\n\t* @return v  new vector\n\t*/\n\texport function vector3(x: number, y: number, z: number): vmath.vector3\n\n\t/**\n\t* Creates a new zero vector with all components set to 0.\n\t* @return v  new zero vector\n\t*/\n\texport function vector4(): vmath.vector4\n\n\t/**\n\t* Creates a new vector with all components set to the\n\t* supplied scalar value.\n\t* @param n  scalar value to splat\n\t* @return v  new vector\n\t*/\n\texport function vector4(n: number): vmath.vector4\n\n\t/**\n\t* Creates a new vector with all components set to the\n\t* corresponding values from the supplied vector. I.e.\n\t* This function creates a copy of the given vector.\n\t* @param v1  existing vector\n\t* @return v  new vector\n\t*/\n\texport function vector4(v1: vmath.vector4): vmath.vector4\n\n\t/**\n\t* Creates a new vector with the components set to the\n\t* supplied values.\n\t* @param x  x coordinate\n\t* @param y  y coordinate\n\t* @param z  z coordinate\n\t* @param w  w coordinate\n\t* @return v  new vector\n\t*/\n\texport function vector4(x: number, y: number, z: number, w: number): vmath.vector4\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace zlib {\n\n\t/**\n\t* A lua error is raised is on error\n\t* @param buf  buffer to deflate\n\t* @return buf  deflated buffer\n\t*/\n\texport function deflate(buf: string): string\n\n\t/**\n\t* A lua error is raised is on error\n\t* @param buf  buffer to inflate\n\t* @return buf  inflated buffer\n\t*/\n\texport function inflate(buf: string): string\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace camera {\n\n\t/**\n\t* Post this message to a camera-component to activate it.\n\t* Several cameras can be active at the same time, but only the camera that was last activated will be used for rendering.\n\t* When the camera is deactivated (see `release_camera_focus`), the previously activated camera will again be used for rendering automatically.\n\t* The reason it is called "camera focus" is the similarity to how acquiring input focus works (see `acquire_input_focus`).\n\t*/\n\texport type acquire_camera_focus = "acquire_camera_focus"\n\n\t/**\n\t* \n\t* Post this message to a camera-component to deactivate it. The camera is then removed from the active cameras.\n\t* See `acquire_camera_focus` for more information how the active cameras are used in rendering.\n\t* \n\t*/\n\texport type release_camera_focus = "release_camera_focus"\n\n\t/**\n\t* \n\t* Post this message to a camera-component to set its properties at run-time.\n\t* \n\t*/\n\texport type set_camera = "set_camera"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace collectionfactory {\n\n\t/**\n\t* loaded\n\t*/\n\texport let STATUS_LOADED: any\n\n\t/**\n\t* loading\n\t*/\n\texport let STATUS_LOADING: any\n\n\t/**\n\t* unloaded\n\t*/\n\texport let STATUS_UNLOADED: any\n\n\t/**\n\t* The URL identifies the collectionfactory component that should do the spawning.\n\t* Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale\n\t* will be applied to the whole collection when spawned.\n\t* Script properties in the created game objects can be overridden through\n\t* a properties-parameter table. The table should contain game object ids\n\t* (hash) as keys and property tables as values to be used when initiating each\n\t* spawned game object.\n\t* See go.property for more information on script properties.\n\t* The function returns a table that contains a key for each game object\n\t* id (hash), as addressed if the collection file was top level, and the\n\t* corresponding spawned instance id (hash) as value with a unique path\n\t* prefix added to each instance.\n\t* ⚠ Calling collectionfactory.create create on a collection factory that is marked as dynamic without having loaded resources\n\t* using collectionfactory.load will synchronously load and create resources which may affect application performance.\n\t* @param url  the collection factory component to be used\n\t* @param position  position to assign to the newly spawned collection\n\t* @param rotation  rotation to assign to the newly spawned collection\n\t* @param properties  table of script properties to propagate to any new game object instances\n\t* @param scale  uniform scaling to apply to the newly spawned collection (must be greater than 0).\n\t* @return ids  a table mapping the id:s from the collection to the new instance id:s\n\t*/\n\texport function create(url: string | hash | url, position?: vmath.vector3, rotation?: vmath.quaternion, properties?: any, scale?: number): any\n\n\t/**\n\t* This returns status of the collection factory.\n\t* Calling this function when the factory is not marked as dynamic loading always returns COMP_COLLECTION_FACTORY_STATUS_LOADED.\n\t* @param url  the collection factory component to get status from\n\t* @return status  status of the collection factory component\n\n- `collectionfactory.STATUS_UNLOADED`\n- `collectionfactory.STATUS_LOADING`\n- `collectionfactory.STATUS_LOADED`\n\n\t*/\n\texport function get_status(url?: string | hash | url): any\n\n\t/**\n\t* Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.\n\t* Calling this function when the factory is not marked as dynamic loading does nothing.\n\t* @param url  the collection factory component to load\n\t* @param complete_function  function to call when resources are loaded.\n\n`self`\nThe current object.\n`url`\nurl of the collection factory component\n`result`\nTrue if resource were loaded successfully\n\n\t*/\n\texport function load(url?: string | hash | url, complete_function?: any): void\n\n\t/**\n\t* This decreases the reference count for each resource loaded with collectionfactory.load. If reference is zero, the resource is destroyed.\n\t* Calling this function when the factory is not marked as dynamic loading does nothing.\n\t* @param url  the collection factory component to unload\n\t*/\n\texport function unload(url?: string | hash | url): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace collectionproxy {\n\n\t/**\n\t* Post this message to a collection-proxy-component to start background loading of the referenced collection.\n\t* When the loading has completed, the message proxy_loaded will be sent back to the script.\n\t* A loaded collection must be initialized (message init) and enabled (message enable) in order to be simulated and drawn.\n\t*/\n\texport type async_load = "async_load"\n\n\t/**\n\t* return an indexed table of missing resources for a collection proxy. Each\n\t* entry is a hexadecimal string that represents the data of the specific\n\t* resource. This representation corresponds with the filename for each\n\t* individual resource that is exported when you bundle an application with\n\t* LiveUpdate functionality. It should be considered good practise to always\n\t* check whether or not there are any missing resources in a collection proxy\n\t* before attempting to load the collection proxy.\n\t* @param collectionproxy  the collectionproxy to check for missing\nresources.\n\t* @return resources  the missing resources\n\t*/\n\texport function missing_resources(collectionproxy: url): any\n\n\t/**\n\t* Post this message to a collection-proxy-component to disable the referenced collection, which in turn disables the contained game objects and components.\n\t*/\n\texport type disable = "disable"\n\n\t/**\n\t* Post this message to a collection-proxy-component to enable the referenced collection, which in turn enables the contained game objects and components.\n\t* If the referenced collection was not initialized prior to this call, it will automatically be initialized.\n\t*/\n\texport type enable = "enable"\n\n\t/**\n\t* Post this message to a collection-proxy-component to finalize the referenced collection, which in turn finalizes the contained game objects and components.\n\t*/\n\texport type final = "final"\n\n\t/**\n\t* Post this message to a collection-proxy-component to initialize the game objects and components in the referenced collection.\n\t* Sending enable to an uninitialized collection proxy automatically initializes it.\n\t* The init message simply provides a higher level of control.\n\t*/\n\texport type init = "init"\n\n\t/**\n\t* Post this message to a collection-proxy-component to start the loading of the referenced collection.\n\t* When the loading has completed, the message proxy_loaded will be sent back to the script.\n\t* A loaded collection must be initialized (message init) and enabled (message enable) in order to be simulated and drawn.\n\t*/\n\texport type load = "load"\n\n\t/**\n\t* This message is sent back to the script that initiated a collection proxy load when the referenced\n\t* collection is loaded. See documentation for load for examples how to use.\n\t*/\n\texport type proxy_loaded = "proxy_loaded"\n\n\t/**\n\t* This message is sent back to the script that initiated an unload with a collection proxy when\n\t* the referenced collection is unloaded. See documentation for unload for examples how to use.\n\t*/\n\texport type proxy_unloaded = "proxy_unloaded"\n\n\t/**\n\t* Post this message to a collection-proxy-component to modify the time-step used when updating the collection controlled by the proxy.\n\t* The time-step is modified by a scaling `factor` and can be incremented either continuously or in discrete steps.\n\t* The continuous mode can be used for slow-motion or fast-forward effects.\n\t* The discrete mode is only useful when scaling the time-step to pass slower than real time (`factor` is below 1).\n\t* The time-step will then be set to 0 for as many frames as the scaling demands and then take on the full real-time-step for one frame,\n\t* to simulate pulses. E.g. if `factor` is set to `0.1` the time-step would be 0 for 9 frames, then be 1/60 for one\n\t* frame, 0 for 9 frames, and so on. The result in practice is that the game looks like it\'s updated at a much lower frequency than 60 Hz,\n\t* which can be useful for debugging when each frame needs to be inspected.\n\t*/\n\texport type set_time_step = "set_time_step"\n\n\t/**\n\t* Post this message to a collection-proxy-component to start the unloading of the referenced collection.\n\t* When the unloading has completed, the message proxy_unloaded will be sent back to the script.\n\t*/\n\texport type unload = "unload"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace factory {\n\n\t/**\n\t* loaded\n\t*/\n\texport let STATUS_LOADED: any\n\n\t/**\n\t* loading\n\t*/\n\texport let STATUS_LOADING: any\n\n\t/**\n\t* unloaded\n\t*/\n\texport let STATUS_UNLOADED: any\n\n\t/**\n\t* The URL identifies which factory should create the game object.\n\t* If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.\n\t* Properties defined in scripts in the created game object can be overridden through the properties-parameter below.\n\t* See go.property for more information on script properties.\n\t* ⚠ Calling factory.create on a factory that is marked as dynamic without having loaded resources\n\t* using factory.load will synchronously load and create resources which may affect application performance.\n\t* @param url  the factory that should create a game object.\n\t* @param position  the position of the new game object, the position of the game object calling `factory.create()` is used by default, or if the value is `nil`.\n\t* @param rotation  the rotation of the new game object, the rotation of the game object calling `factory.create()` is used by default, or if the value is `nil`.\n\t* @param properties  the properties defined in a script attached to the new game object.\n\t* @param scale  the scale of the new game object (must be greater than 0), the scale of the game object containing the factory is used by default, or if the value is `nil`\n\t* @return id  the global id of the spawned game object\n\t*/\n\texport function create(url: string | hash | url, position?: vmath.vector3, rotation?: vmath.quaternion, properties?: any, scale?: number | vmath.vector3): hash\n\n\t/**\n\t* This returns status of the factory.\n\t* Calling this function when the factory is not marked as dynamic loading always returns\n\t* factory.STATUS_LOADED.\n\t* @param url  the factory component to get status from\n\t* @return status  status of the factory component\n\n- `factory.STATUS_UNLOADED`\n- `factory.STATUS_LOADING`\n- `factory.STATUS_LOADED`\n\n\t*/\n\texport function get_status(url?: string | hash | url): any\n\n\t/**\n\t* Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.\n\t* Calling this function when the factory is not marked as dynamic loading does nothing.\n\t* @param url  the factory component to load\n\t* @param complete_function  function to call when resources are loaded.\n\n`self`\nThe current object.\n`url`\nurl of the factory component\n`result`\nTrue if resources were loaded successfully\n\n\t*/\n\texport function load(url?: string | hash | url, complete_function?: any): void\n\n\t/**\n\t* This decreases the reference count for each resource loaded with factory.load. If reference is zero, the resource is destroyed.\n\t* Calling this function when the factory is not marked as dynamic loading does nothing.\n\t* @param url  the factory component to unload\n\t*/\n\texport function unload(url?: string | hash | url): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace label {\n\n\t/**\n\t* The color of the label. The type of the property is vector4.\n\t*/\n\texport let color: any\n\n\t/**\n\t* The font used when rendering the label. The type of the property is hash.\n\t*/\n\texport let font: any\n\n\t/**\n\t* Gets the text from a label component\n\t* @param url  the label to get the text from\n\t* @return metrics  the label text\n\t*/\n\texport function get_text(url: string | hash | url): string\n\n\t/**\n\t* Gets the text metrics from a label component\n\t* @param url  the label to get the (unscaled) metrics from\n\t* @return metrics  a table with the following fields:\n\n- width\n- height\n- max_ascent\n- max_descent\n\n\t*/\n\texport function get_text_metrics(url: string | hash | url): any\n\n\t/**\n\t* Sets the text of a label component\n\t* ⚠ This method uses the message passing that means the value will be set after `dispatch messages` step.\n\t* More information is available in the Application Lifecycle manual.\n\t* @param url  the label that should have a constant set\n\t* @param text  the text\n\t*/\n\texport function set_text(url: string | hash | url, text: string): void\n\n\t/**\n\t* The material used when rendering the label. The type of the property is hash.\n\t*/\n\texport let material: any\n\n\t/**\n\t* The outline color of the label. The type of the property is vector4.\n\t*/\n\texport let outline: any\n\n\t/**\n\t* The scale of the label. The type of the property is number (uniform)\n\t* or vector3 (non uniform).\n\t*/\n\texport let scale: any\n\n\t/**\n\t* The shadow color of the label. The type of the property is vector4.\n\t*/\n\texport let shadow: any\n\n\t/**\n\t* Returns the size of the label. The size will constrain the text if line break is enabled.\n\t* The type of the property is vector3.\n\t*/\n\texport let size: any\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace model {\n\n\t/**\n\t* The current animation set on the component. The type of the property is hash.\n\t*/\n\texport let animation: any\n\n\t/**\n\t* The normalized animation cursor. The type of the property is number.\n\t* ⚠ Please note that model events may not fire as expected when the cursor is manipulated directly.\n\t*/\n\texport let cursor: any\n\n\t/**\n\t* The material used when rendering the model. The type of the property is hash.\n\t*/\n\texport let material: any\n\n\t/**\n\t* Cancels all animation on a model component.\n\t* @param url  the model for which to cancel the animation\n\t*/\n\texport function cancel(url: string | hash | url): void\n\n\t/**\n\t* Gets the id of the game object that corresponds to a model skeleton bone.\n\t* The returned game object can be used for parenting and transform queries.\n\t* This function has complexity `O(n)`, where `n` is the number of bones in the model skeleton.\n\t* Game objects corresponding to a model skeleton bone can not be individually deleted.\n\t* @param url  the model to query\n\t* @param bone_id  id of the corresponding bone\n\t* @return id  id of the game object\n\t*/\n\texport function get_go(url: string | hash | url, bone_id: string | hash): hash\n\n\t/**\n\t* Plays an animation on a model component with specified playback\n\t* mode and parameters.\n\t* An optional completion callback function can be provided that will be called when\n\t* the animation has completed playing. If no function is provided,\n\t* a model_animation_done message is sent to the script that started the animation.\n\t* ⚠ The callback is not called (or message sent) if the animation is\n\t* cancelled with model.cancel. The callback is called (or message sent) only for\n\t* animations that play with the following playback modes:\n\t* \n\t* - `go.PLAYBACK_ONCE_FORWARD`\n\t* - `go.PLAYBACK_ONCE_BACKWARD`\n\t* - `go.PLAYBACK_ONCE_PINGPONG`\n\t* \n\t* @param url  the model for which to play the animation\n\t* @param anim_id  id of the animation to play\n\t* @param playback  playback mode of the animation\n\n- `go.PLAYBACK_ONCE_FORWARD`\n- `go.PLAYBACK_ONCE_BACKWARD`\n- `go.PLAYBACK_ONCE_PINGPONG`\n- `go.PLAYBACK_LOOP_FORWARD`\n- `go.PLAYBACK_LOOP_BACKWARD`\n- `go.PLAYBACK_LOOP_PINGPONG`\n\n\t* @param play_properties  optional table with properties\nPlay properties table:\n\n`blend_duration`\nDuration of a linear blend between the current and new animation.\n`offset`\nThe normalized initial value of the animation cursor when the animation starts playing.\n`playback_rate`\nThe rate with which the animation will be played. Must be positive.\n\n\t* @param complete_function  function to call when the animation has completed.\n\n`self`\nThe current object.\n`message_id`\nThe name of the completion message, `"model_animation_done"`.\n`message`\nInformation about the completion:\n\n\n`animation_id` - the animation that was completed.\n`playback` - the playback mode for the animation.\n\n\n`sender`\nThe invoker of the callback: the model component.\n\n\t*/\n\texport function play_anim(url: string | hash | url, anim_id: string | hash, playback: any, play_properties?: any, complete_function?: any): void\n\n\t/**\n\t* This message is sent when a Model animation has finished playing back to the script\n\t* that started the animation.\n\t* ⚠ No message is sent if a completion callback function was supplied\n\t* when the animation was started. No message is sent if the animation is cancelled with\n\t* model.cancel(). This message is sent only for animations that play with\n\t* the following playback modes:\n\t* \n\t* - `go.PLAYBACK_ONCE_FORWARD`\n\t* - `go.PLAYBACK_ONCE_BACKWARD`\n\t* - `go.PLAYBACK_ONCE_PINGPONG`\n\t* \n\t*/\n\texport type model_animation_done = "model_animation_done"\n\n\t/**\n\t* The animation playback rate. A multiplier to the animation playback rate. The type of the property is number.\n\t*/\n\texport let playback_rate: any\n\n\t/**\n\t* The texture hash id of the model. Used for getting/setting model texture for unit 0-7\n\t*/\n\texport let textureN: any\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace particlefx {\n\n\t/**\n\t* postspawn state\n\t*/\n\texport let EMITTER_STATE_POSTSPAWN: any\n\n\t/**\n\t* prespawn state\n\t*/\n\texport let EMITTER_STATE_PRESPAWN: any\n\n\t/**\n\t* sleeping state\n\t*/\n\texport let EMITTER_STATE_SLEEPING: any\n\n\t/**\n\t* spawning state\n\t*/\n\texport let EMITTER_STATE_SPAWNING: any\n\n\t/**\n\t* Starts playing a particle FX component.\n\t* Particle FX started this way need to be manually stopped through `particlefx.stop()`.\n\t* Which particle FX to play is identified by the URL.\n\t* ⚠ A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call `particlefx.stop()` to stop it from emitting more particles.\n\t* @param url  the particle fx that should start playing.\n\t* @param emitter_state_function  optional callback function that will be called when an emitter attached to this particlefx changes state.\n\n`self`\nThe current object\n`id`\nThe id of the particle fx component\n`emitter`\nThe id of the emitter\n`state`\nthe new state of the emitter:\n\n\n- `particlefx.EMITTER_STATE_SLEEPING`\n- `particlefx.EMITTER_STATE_PRESPAWN`\n- `particlefx.EMITTER_STATE_SPAWNING`\n- `particlefx.EMITTER_STATE_POSTSPAWN`\n\n\t*/\n\texport function play(url: string | hash | url, emitter_state_function?: any): void\n\n\t/**\n\t* Resets a shader constant for a particle FX component emitter.\n\t* The constant must be defined in the material assigned to the emitter.\n\t* Resetting a constant through this function implies that the value defined in the material will be used.\n\t* Which particle FX to reset a constant for is identified by the URL.\n\t* @param url  the particle FX that should have a constant reset\n\t* @param emitter  the id of the emitter\n\t* @param constant  the name of the constant\n\t*/\n\texport function reset_constant(url: string | hash | url, emitter: string | hash, constant: string | hash): void\n\n\t/**\n\t* Sets a shader constant for a particle FX component emitter.\n\t* The constant must be defined in the material assigned to the emitter.\n\t* Setting a constant through this function will override the value set for that constant in the material.\n\t* The value will be overridden until particlefx.reset_constant is called.\n\t* Which particle FX to set a constant for is identified by the URL.\n\t* @param url  the particle FX that should have a constant set\n\t* @param emitter  the id of the emitter\n\t* @param constant  the name of the constant\n\t* @param value  the value of the constant\n\t*/\n\texport function set_constant(url: string | hash | url, emitter: string | hash, constant: string | hash, value: vmath.vector4): void\n\n\t/**\n\t* Stops a particle FX component from playing.\n\t* Stopping a particle FX does not remove already spawned particles.\n\t* Which particle FX to stop is identified by the URL.\n\t* @param url  the particle fx that should stop playing\n\t*/\n\texport function stop(url: string | hash | url): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace sound {\n\n\t/**\n\t* The gain on the sound-component. Note that gain is in linear scale,\n\t* between 0 and 1.\n\t*/\n\texport let gain: any\n\n\t/**\n\t* The pan on the sound-component. The valid range is from -1.0 to 1.0,\n\t* representing -45 degrees left, to +45 degrees right.\n\t*/\n\texport let pan: any\n\n\t/**\n\t* Post this message to a sound-component to make it play its sound. Multiple voices is supported. The limit is set to 32 voices per sound component.\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t* ⚠ A sound will continue to play even if the game object the sound component belonged to is deleted. You can send a `stop_sound` to stop the sound.\n\t*/\n\texport type play_sound = "play_sound"\n\n\t/**\n\t* Post this message to a sound-component to set gain on all active playing voices.\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t*/\n\texport type set_gain = "set_gain"\n\n\t/**\n\t* The sound data used when playing the sound. The type of the property is hash.\n\t*/\n\texport let sound: any\n\n\t/**\n\t* Get mixer group gain\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t* @param group  group name\n\t* @return gain  gain in linear scale\n\t*/\n\texport function get_group_gain(group: string | hash): number\n\n\t/**\n\t* Get a mixer group name as a string.\n\t* ⚠ This function is to be used for debugging and\n\t* development tooling only. The function does a reverse hash lookup, which does not\n\t* return a proper string value when the game is built in release mode.\n\t* @param group  group name\n\t* @return name  group name\n\t*/\n\texport function get_group_name(group: string | hash): string\n\n\t/**\n\t* Get a table of all mixer group names (hashes).\n\t* @return groups  table of mixer group names\n\t*/\n\texport function get_groups(): any\n\n\t/**\n\t* Get peak value from mixer group.\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t* Also note that the returned value might be an approximation and in particular\n\t* the effective window might be larger than specified.\n\t* @param group  group name\n\t* @param window  window length in seconds\n\t* @return peak_l  peak value for left channel\n\t* @return peak_r  peak value for right channel\n\t*/\n\texport function get_peak(group: string | hash, window: number): LuaMultiReturn<[number, number]>\n\n\t/**\n\t* Get RMS (Root Mean Square) value from mixer group. This value is the\n\t* square root of the mean (average) value of the squared function of\n\t* the instantaneous values.\n\t* For instance: for a sinewave signal with a peak gain of -1.94 dB (0.8 linear),\n\t* the RMS is `0.8 &times; 1/sqrt(2)` which is about 0.566.\n\t* ⚠ Note the returned value might be an approximation and in particular\n\t* the effective window might be larger than specified.\n\t* @param group  group name\n\t* @param window  window length in seconds\n\t* @return rms_l  RMS value for left channel\n\t* @return rms_r  RMS value for right channel\n\t*/\n\texport function get_rms(group: string | hash, window: number): LuaMultiReturn<[number, number]>\n\n\t/**\n\t* Checks if background music is playing, e.g. from iTunes.\n\t* 🌎 On non mobile platforms,\n\t* this function always return `false`.\n\t* 🌎 On Android you can only get a correct reading\n\t* of this state if your game is not playing any sounds itself. This is a limitation\n\t* in the Android SDK. If your game is playing any sounds, *even with a gain of zero*, this\n\t* function will return `false`.\n\t* The best time to call this function is:\n\t* \n\t* - In the `init` function of your main collection script before any sounds are triggered\n\t* - In a window listener callback when the window.WINDOW_EVENT_FOCUS_GAINED event is received\n\t* \n\t* Both those times will give you a correct reading of the state even when your application is\n\t* swapped out and in while playing sounds and it works equally well on Android and iOS.\n\t* @return playing  `true` if music is playing, otherwise `false`.\n\t*/\n\texport function is_music_playing(): boolean\n\n\t/**\n\t* Checks if a phone call is active. If there is an active phone call all\n\t* other sounds will be muted until the phone call is finished.\n\t* 🌎 On non mobile platforms,\n\t* this function always return `false`.\n\t* @return call_active  `true` if there is an active phone call, `false` otherwise.\n\t*/\n\texport function is_phone_call_active(): boolean\n\n\t/**\n\t* Pause all active voices\n\t* @param url  the sound that should pause\n\t* @param pause  true if the sound should pause\n\t*/\n\texport function pause(url: string | hash | url, pause: any): void\n\n\t/**\n\t* Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t* ⚠ A sound will continue to play even if the game object the sound component belonged to is deleted. You can call `sound.stop()` to stop the sound.\n\t* @param url  the sound that should play\n\t* @param play_properties  \noptional table with properties:\n`delay`\ndelay in seconds before the sound starts playing, default is 0.\n`gain`\nsound gain between 0 and 1, default is 1. The final gain of the sound will be a combination of this gain, the group gain and the master gain.\n`pan`\nsound pan between -1 and 1, default is 0. The final pan of the sound will be an addition of this pan and the sound pan.\n`speed`\nsound speed where 1.0 is normal speed, 0.5 is half speed and 2.0 is double speed. The final speed of the sound will be a multiplication of this speed and the sound speed.\n\n\t* @param complete_function  function to call when the sound has finished playing.\n\n`self`\nThe current object.\n`message_id`\nThe name of the completion message, `"sound_done"`.\n`message`\nInformation about the completion:\n\n\n`play_id` - the sequential play identifier that was given by the sound.play function.\n\n\n`sender`\nThe invoker of the callback: the sound component.\n\n\t*/\n\texport function play(url: string | hash | url, play_properties?: any, complete_function?: any): void\n\n\t/**\n\t* Set gain on all active playing voices of a sound.\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t* @param url  the sound to set the gain of\n\t* @param gain  sound gain between 0 and 1. The final gain of the sound will be a combination of this gain, the group gain and the master gain.\n\t*/\n\texport function set_gain(url: string | hash | url, gain?: number): void\n\n\t/**\n\t* Set mixer group gain\n\t* ⚠ Note that gain is in linear scale, between 0 and 1.\n\t* To get the dB value from the gain, use the formula `20 * log(gain)`.\n\t* Inversely, to find the linear value from a dB value, use the formula\n\t* `10db/20`.\n\t* @param group  group name\n\t* @param gain  gain in linear scale\n\t*/\n\texport function set_group_gain(group: string | hash, gain: number): void\n\n\t/**\n\t* Set panning on all active playing voices of a sound.\n\t* The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.\n\t* @param url  the sound to set the panning value to\n\t* @param pan  sound panning between -1.0 and 1.0\n\t*/\n\texport function set_pan(url: string | hash | url, pan?: number): void\n\n\t/**\n\t* Stop playing all active voices\n\t* @param url  the sound that should stop\n\t*/\n\texport function stop(url: string | hash | url): void\n\n\t/**\n\t* This message is sent back to the sender of a `play_sound` message, if the sound\n\t* could be played to completion.\n\t*/\n\texport type sound_done = "sound_done"\n\n\t/**\n\t* The speed on the sound-component where 1.0 is normal speed, 0.5 is half\n\t* speed and 2.0 is double speed.\n\t*/\n\texport let speed: any\n\n\t/**\n\t* Post this message to a sound-component to make it stop playing all active voices\n\t*/\n\texport type stop_sound = "stop_sound"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace spine {\n\n\t/**\n\t* READ ONLY The current animation set on the component.\n\t* hash.\n\t*/\n\texport let animation: any\n\n\t/**\n\t* The normalized animation cursor. The type of the property is number.\n\t* ⚠ Please note that spine events may not fire as expected when the cursor is manipulated directly.\n\t*/\n\texport let cursor: any\n\n\t/**\n\t* The material used when rendering the spine model. The type of the property is hash.\n\t*/\n\texport let material: any\n\n\t/**\n\t* number.\n\t* The playback_rate is a non-negative number, a negative value will be clamped to 0.\n\t*/\n\texport let playback_rate: any\n\n\t/**\n\t* The current skin on the component. The type of the property is hash.\n\t* If setting the skin property the skin must be present on the spine\n\t* model or a runtime error is signalled.\n\t*/\n\texport let skin: any\n\n\t/**\n\t* Cancels all running animations on a specified spine model component.\n\t* @param url  the spine model for which to cancel the animation\n\t*/\n\texport function cancel(url: string | hash | url): void\n\n\t/**\n\t* Returns the id of the game object that corresponds to a specified skeleton bone.\n\t* The returned game object can be used for parenting and transform queries.\n\t* This function has complexity `O(n)`, where `n` is the number of bones in the spine model skeleton.\n\t* Game objects corresponding to a spine model skeleton bone can not be individually deleted.\n\t* @param url  the spine model to query\n\t* @param bone_id  id of the corresponding bone\n\t* @return id  id of the game object\n\t*/\n\texport function get_go(url: string | hash | url, bone_id: string | hash): hash\n\n\t/**\n\t* Plays a specified animation on a spine model component with specified playback\n\t* mode and parameters.\n\t* An optional completion callback function can be provided that will be called when\n\t* the animation has completed playing. If no function is provided,\n\t* a spine_animation_done message is sent to the script that started the animation.\n\t* ⚠ The callback is not called (or message sent) if the animation is\n\t* cancelled with spine.cancel. The callback is called (or message sent) only for\n\t* animations that play with the following playback modes:\n\t* \n\t* - `go.PLAYBACK_ONCE_FORWARD`\n\t* - `go.PLAYBACK_ONCE_BACKWARD`\n\t* - `go.PLAYBACK_ONCE_PINGPONG`\n\t* \n\t* @param url  the spine model for which to play the animation\n\t* @param anim_id  id of the animation to play\n\t* @param playback  playback mode of the animation\n\n- `go.PLAYBACK_ONCE_FORWARD`\n- `go.PLAYBACK_ONCE_BACKWARD`\n- `go.PLAYBACK_ONCE_PINGPONG`\n- `go.PLAYBACK_LOOP_FORWARD`\n- `go.PLAYBACK_LOOP_BACKWARD`\n- `go.PLAYBACK_LOOP_PINGPONG`\n\n\t* @param play_properties  optional table with properties:\n\n`blend_duration`\nduration of a linear blend between the current and new animation.\n`offset`\nthe normalized initial value of the animation cursor when the animation starts playing.\n`playback_rate`\nthe rate with which the animation will be played. Must be positive.\n\n\t* @param complete_function  function to call when the animation has completed.\n\n`self`\nThe current object.\n`message_id`\nThe name of the completion message, `"spine_animation_done"`.\n`message`\nInformation about the completion:\n\n\n`animation_id` - the animation that was completed.\n`playback` - the playback mode for the animation.\n\n\n`sender`\nThe invoker of the callback: the spine model component.\n\n\t*/\n\texport function play_anim(url: string | hash | url, anim_id: string | hash, playback: any, play_properties?: any, complete_function?: any): void\n\n\t/**\n\t* Resets any previously set IK target of a spine model, the position will be reset\n\t* to the original position from the spine scene.\n\t* @param url  the spine model containing the object\n\t* @param ik_constraint_id  id of the corresponding IK constraint object\n\t*/\n\texport function reset_ik_target(url: string | hash | url, ik_constraint_id: string | hash): void\n\n\t/**\n\t* Sets a game object as target position of an inverse kinematic (IK) object. As the\n\t* target game object\'s position is updated, the constraint object is updated with the\n\t* new position.\n\t* @param url  the spine model containing the object\n\t* @param ik_constraint_id  id of the corresponding IK constraint object\n\t* @param target_url  target game object\n\t*/\n\texport function set_ik_target(url: string | hash | url, ik_constraint_id: string | hash, target_url: string | hash | url): void\n\n\t/**\n\t* Sets a static (vector3) target position of an inverse kinematic (IK) object.\n\t* @param url  the spine model containing the object\n\t* @param ik_constraint_id  id of the corresponding IK constraint object\n\t* @param position  target position\n\t*/\n\texport function set_ik_target_position(url: string | hash | url, ik_constraint_id: string | hash, position: vmath.vector3): void\n\n\t/**\n\t* Sets the spine skin on a spine model.\n\t* @param url  the spine model for which to set skin\n\t* @param spine_skin  spine skin id\n\t* @param spine_slot  optional slot id to only change a specific slot\n\t*/\n\texport function set_skin(url: string | hash | url, spine_skin: string | hash, spine_slot?: string | hash): void\n\n\t/**\n\t* This message is sent when a Spine animation has finished playing back to the script\n\t* that started the animation.\n\t* ⚠ No message is sent if a completion callback function was supplied\n\t* when the animation was started. No message is sent if the animation is cancelled with\n\t* model.cancel(). This message is sent only for animations that play with\n\t* the following playback modes:\n\t* \n\t* - `go.PLAYBACK_ONCE_FORWARD`\n\t* - `go.PLAYBACK_ONCE_BACKWARD`\n\t* - `go.PLAYBACK_ONCE_PINGPONG`\n\t* \n\t*/\n\texport type spine_animation_done = "spine_animation_done"\n\n\t/**\n\t* This message is sent when Spine animation playback fires events. These events\n\t* has to be defined on the animation track in the Spine animation editor. An event\n\t* can contain custom values expressed in the fields `integer`, `float` and `string`.\n\t*/\n\texport type spine_event = "spine_event"\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace sprite {\n\n\t/**\n\t* This message is sent to the sender of a `play_animation` message when the\n\t* animation has completed.\n\t* Note that this message is sent only for animations that play with the following\n\t* playback modes:\n\t* \n\t* - Once Forward\n\t* - Once Backward\n\t* - Once Ping Pong\n\t* \n\t* See play_animation for more information and examples of how to use\n\t* this message.\n\t*/\n\texport type animation_done = "animation_done"\n\n\t/**\n\t* The normalized animation cursor. The type of the property is number.\n\t*/\n\texport let cursor: any\n\n\t/**\n\t* The image used when rendering the sprite. The type of the property is hash.\n\t*/\n\texport let image: any\n\n\t/**\n\t* The material used when rendering the sprite. The type of the property is hash.\n\t*/\n\texport let material: any\n\n\t/**\n\t* Post this message to a sprite component to make it play an animation from its tile set.\n\t*/\n\texport type play_animation = "play_animation"\n\n\t/**\n\t* number.\n\t* The playback_rate is a non-negative number, a negative value will be clamped to 0.\n\t*/\n\texport let playback_rate: any\n\n\t/**\n\t* The non-uniform scale of the sprite. The type of the property is vector3.\n\t*/\n\texport let scale: any\n\n\t/**\n\t* READ ONLY Returns the size of the sprite, not allowing for any additional scaling that may be applied.\n\t* The type of the property is vector3.\n\t*/\n\texport let size: any\n\n\t/**\n\t* Play an animation on a sprite component from its tile set\n\t* An optional completion callback function can be provided that will be called when\n\t* the animation has completed playing. If no function is provided,\n\t* a animation_done message is sent to the script that started the animation.\n\t* @param url  the sprite that should play the animation\n\t* @param id  hash name hash of the animation to play\n\t* @param complete_function  function to call when the animation has completed.\n\n`self`\nThe current object.\n`message_id`\nThe name of the completion message, `"animation_done"`.\n`message`\nInformation about the completion:\n\n\n`current_tile` - the current tile of the sprite.\n`id` - id of the animation that was completed.\n\n\n`sender`\nThe invoker of the callback: the sprite component.\n\n\t* @param play_properties  optional table with properties:\n\n`offset`\nthe normalized initial value of the animation cursor when the animation starts playing.\n`playback_rate`\nthe rate with which the animation will be played. Must be positive.\n\n\t*/\n\texport function play_flipbook(url: string | hash | url, id: any, complete_function?: any, play_properties?: any): void\n\n\t/**\n\t* Sets horizontal flipping of the provided sprite\'s animations.\n\t* The sprite is identified by its URL.\n\t* If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.\n\t* @param url  the sprite that should flip its animations\n\t* @param flip  `true` if the sprite should flip its animations, `false` if not\n\t*/\n\texport function set_hflip(url: string | hash | url, flip: boolean): void\n\n\t/**\n\t* Sets vertical flipping of the provided sprite\'s animations.\n\t* The sprite is identified by its URL.\n\t* If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.\n\t* @param url  the sprite that should flip its animations\n\t* @param flip  `true` if the sprite should flip its animations, `false` if not\n\t*/\n\texport function set_vflip(url: string | hash | url, flip: boolean): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n\ndeclare namespace tilemap {\n\n\t/**\n\t* The material used when rendering the tile map. The type of the property is hash.\n\t*/\n\texport let material: any\n\n\t/**\n\t* The tile source used when rendering the tile map. The type of the property is hash.\n\t*/\n\texport let tile_source: any\n\n\t/**\n\t* Get the bounds for a tile map. This function returns multiple values:\n\t* The lower left corner index x and y coordinates (1-indexed),\n\t* the tile map width and the tile map height.\n\t* The resulting values take all tile map layers into account, meaning that\n\t* the bounds are calculated as if all layers were collapsed into one.\n\t* @param url  the tile map\n\t* @return x  x coordinate of the bottom left corner\n\t* @return y  y coordinate of the bottom left corner\n\t* @return w  number of columns (width) in the tile map\n\t* @return h  number of rows (height) in the tile map\n\t*/\n\texport function get_bounds(url: string | hash | url): LuaMultiReturn<[number, number, number, number]>\n\n\t/**\n\t* Get the tile set at the specified position in the tilemap.\n\t* The position is identified by the tile index starting at origin\n\t* with index 1, 1. (see tilemap.set_tile())\n\t* Which tile map and layer to query is identified by the URL and the\n\t* layer name parameters.\n\t* @param url  the tile map\n\t* @param layer  name of the layer for the tile\n\t* @param x  x-coordinate of the tile\n\t* @param y  y-coordinate of the tile\n\t* @return tile  index of the tile\n\t*/\n\texport function get_tile(url: string | hash | url, layer: string | hash, x: number, y: number): number\n\n\t/**\n\t* Replace a tile in a tile map with a new tile.\n\t* The coordinates of the tiles are indexed so that the "first" tile just\n\t* above and to the right of origin has coordinates 1,1.\n\t* Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.\n\t* \n\t* +-------+-------+------+------+\n\t* |  0,3  |  1,3  | 2,3  | 3,3  |\n\t* +-------+-------+------+------+\n\t* |  0,2  |  1,2  | 2,2  | 3,2  |\n\t* +-------+-------+------+------+\n\t* |  0,1  |  1,1  | 2,1  | 3,1  |\n\t* +-------O-------+------+------+\n\t* |  0,0  |  1,0  | 2,0  | 3,0  |\n\t* +-------+-------+------+------+\n\t* \n\t* \n\t* The coordinates must be within the bounds of the tile map as it were created.\n\t* That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.\n\t* To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.\n\t* @param url  the tile map\n\t* @param layer  name of the layer for the tile\n\t* @param x  x-coordinate of the tile\n\t* @param y  y-coordinate of the tile\n\t* @param tile  index of new tile to set. 0 resets the cell\n\t* @param h_flipped  optional if the tile should be horizontally flipped\n\t* @param v_flipped  optional i the tile should be vertically flipped\n\t*/\n\texport function set_tile(url: string | hash | url, layer: string | hash, x: number, y: number, tile: number, h_flipped?: boolean, v_flipped?: boolean): void\n\n\t/**\n\t* Sets the visibility of the tilemap layer\n\t* @param url  the tile map\n\t* @param layer  name of the layer for the tile\n\t* @param visible  should the layer be visible\n\t*/\n\texport function set_visible(url: string | hash | url, layer: string | hash, visible: boolean): void\n\n}\n// =^..^=   =^..^=   =^..^=    =^..^=    =^..^=    =^..^=    =^..^= //\n\n'}}]);
//# sourceMappingURL=7d0097fc-da63e5ad6746debe3f6e.js.map